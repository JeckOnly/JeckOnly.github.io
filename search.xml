<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flow异常处理</title>
    <url>/2023/02/09/Flow%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>它们的函数注释一言难尽，建议别看，onCompletion的注释不太对。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;0 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;1 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .collect()<span class="comment">// 声明式写法，collect代码块内容写在onEach中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line"></span><br><span class="line">Got <span class="number">1</span></span><br><span class="line"><span class="number">0</span> Done fail</span><br><span class="line"><span class="number">1</span> Done fail</span><br><span class="line"><span class="number">1</span> <span class="keyword">catch</span> java.lang.IllegalStateException: Crash on <span class="number">2</span></span><br><span class="line"><span class="number">2</span> Done successfully</span><br></pre></td></tr></table></figure>



<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><ol>
<li>只能捕捉到上游的异常，下游无法（所以它<strong>根本不能捕获终端操作符中抛出的异常</strong>）。</li>
<li>只有捕捉到异常，才进入代码块。</li>
<li>可以抛出其他异常</li>
<li>可以emit值</li>
</ol>
<h3 id="onCompletion"><a href="#onCompletion" class="headerlink" title="onCompletion"></a>onCompletion</h3><p>这个有点复杂，分情况讨论。</p>
<h4 id="正常结束"><a href="#正常结束" class="headerlink" title="正常结束"></a>正常结束</h4><ol>
<li>onCompletion操作符按声明顺序，依次进入其代码块执行，异常参数为null</li>
<li>可以emit值</li>
</ol>
<h4 id="异常结束"><a href="#异常结束" class="headerlink" title="异常结束"></a>异常结束</h4><p>异常结束的时候，一个onCompletion操作符异常参数依然有可能为null。</p>
<ol>
<li>为null的情况是：<strong>该操作符和异常抛出处之间（注意之间），有catch捕获了该异常，且catch没有抛出异常，且终端操作符没有抛出异常。</strong></li>
<li>其他情况，异常参数都不为null。</li>
</ol>
<p><strong>当异常参数不为null的情况下（不管它正常结束还是异常结束）才可以在代码块中emit值。</strong></p>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 0</span></span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            emit(<span class="number">100</span>)</span><br><span class="line">        &#125;<span class="comment">// 1</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;1 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 3</span></span><br><span class="line">        .collect&#123;&#125;<span class="comment">// 声明式写法，collect代码块内容写在onEach中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例已异常结束，0&#x2F;1处异常参数不为空，2处为空（catch把它捕获了）。</p>
<p><strong>如果终端有异常，所有onCompletion操作符异常参数都不为空。</strong></p>
<p>另外，catch和onCompletion的执行顺序按照<strong>声明顺序</strong>（如果某catch可以执行的话）。</p>
<h3 id="声明式写法"><a href="#声明式写法" class="headerlink" title="声明式写法"></a>声明式写法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">    .onEach &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">        println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;.onCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为了让catch可以捕获<strong>所有异常</strong>，把catch放到collect之前，collect留空，业务代码写在onEach中。</li>
<li>onCompletion一定可以执行，上面的写法中，如果上游有异常，异常参数是会不为null，但是我们不要管它，留给catch来处理。这里的执行顺序是onCompletion再catch。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;.<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">            println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        &#125;.onCompletion &#123;</span><br><span class="line">            println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调换位置。</p>
<p>第一个写法是catch可以捕获到onCompletion的异常，第二种不行。第二种先catch再onCompletion。</p>
<p>参考资料：<a href="https://medium.com/mobile-app-development-publication/kotlin-flow-imperative-or-declarative-exception-handler-bf8d64936366">medium</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
  </entry>
  <entry>
    <title>Flow操作符——缓冲</title>
    <url>/2023/02/08/Flow%E6%93%8D%E4%BD%9C%E7%AC%A6%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h2 id="Buffer操作符"><a href="#Buffer操作符" class="headerlink" title="Buffer操作符"></a>Buffer操作符</h2><p>之前在旧博客用模拟餐厅上菜的例子讲过这个操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上菜——鸡肉</span><br><span class="line">运送鸡肉</span><br><span class="line">客人开始吃鸡肉</span><br><span class="line">客人吃完鸡肉</span><br><span class="line">上菜——鱼肉</span><br><span class="line">运送鱼肉</span><br><span class="line">客人开始吃鱼肉</span><br><span class="line">客人吃完鱼肉</span><br><span class="line">上菜——西瓜</span><br><span class="line">运送西瓜</span><br><span class="line">客人开始吃西瓜</span><br><span class="line">客人吃完西瓜</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>因为emit会挂起等collect执行完再resume，所以下一个菜要等客人吃完才上</strong>，那可不可以等客人一边吃就一边上菜呢？即要实现：collect不会令emit挂起，并保证emit的值按顺序到达，collect也对应的<strong>不取消（collectLatest就会取消）</strong>，也按顺序对应执行。</p>
<p><strong>用buffer可以解决</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.buffer().collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上菜——鸡肉</span><br><span class="line">运送鸡肉</span><br><span class="line">客人开始吃鸡肉</span><br><span class="line">上菜——鱼肉</span><br><span class="line">运送鱼肉</span><br><span class="line">上菜——西瓜</span><br><span class="line">运送西瓜</span><br><span class="line">客人吃完鸡肉</span><br><span class="line">客人开始吃鱼肉</span><br><span class="line">客人吃完鱼肉</span><br><span class="line">客人开始吃西瓜</span><br><span class="line">客人吃完西瓜</span><br></pre></td></tr></table></figure>

<p>由于有缓冲，上游和下游可以 <strong>并发</strong> 地执行。</p>
<h2 id="实现缓冲的另外一个方法"><a href="#实现缓冲的另外一个方法" class="headerlink" title="实现缓冲的另外一个方法"></a>实现缓冲的另外一个方法</h2><p>其实把 <code>buffer()</code> 改为 <code>flowOn(other Dispatcher)</code> （other Dispatcher指的是不同于 <code>collect</code> 所运行的上下文的调度器），也可以达到缓冲的效果。文档是这样说的：</p>
<blockquote>
<p>This operator retains a <em>sequential</em> nature of flow if changing the context does not call for changing the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">dispatcher</a>. </p>
<p>Otherwise, if <strong>changing dispatcher</strong> is required, it collects flow emissions <strong>in one coroutine</strong> that is run using a specified <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">context</a> and emits them from <strong>another coroutines</strong> with the original collector’s context using a channel with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/-factory/-b-u-f-f-e-r-e-d.html">default</a> <strong>buffer</strong> size between two coroutines similarly to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> operator, unless <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> operator is explicitly called before or after <code>flowOn</code>, which requests buffering behavior and specifies channel size.</p>
</blockquote>
<p>要就是说，要是 <code>flowOn()</code>中指定的调度器和收集的调度器不同，这样 <code>emit</code> 和 <code>collect</code> 就会运行在两个不同的协程中，然后有一个带有缓冲的channel把它们连接起来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.IO).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.Default).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(CoroutineName(<span class="string">&quot;没有改变调度器&quot;</span>)).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Buffer的参数"><a href="#Buffer的参数" class="headerlink" title="Buffer的参数"></a>Buffer的参数</h2><p>有两个参数，分别是 <strong>缓冲区大小</strong>和 <strong>溢出时的行为</strong>，都很简单，看注释即可。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a channel with an unlimited capacity buffer in the `Channel(...)` factory function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> UNLIMITED: <span class="built_in">Int</span> = <span class="built_in">Int</span>.MAX_VALUE   没有限制</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a rendezvous channel in the `Channel(...)` factory function &amp;mdash; a channel that does not have a buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> RENDEZVOUS: <span class="built_in">Int</span> = <span class="number">0</span>     没有缓冲，缓冲区为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a conflated channel in the `Channel(...)` factory function. This is a shortcut to creating</span></span><br><span class="line"><span class="comment"> * a channel with [`onBufferOverflow = DROP_OLDEST`][BufferOverflow.DROP_OLDEST].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> CONFLATED: <span class="built_in">Int</span> = -<span class="number">1</span>  缓冲区为<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a buffered channel with the default buffer capacity in the `Channel(...)` factory function.</span></span><br><span class="line"><span class="comment"> * The default capacity for a channel that [suspends][BufferOverflow.SUSPEND] on overflow</span></span><br><span class="line"><span class="comment"> * is 64 and can be overridden by setting [DEFAULT_BUFFER_PROPERTY_NAME] on JVM.</span></span><br><span class="line"><span class="comment"> * For non-suspending channels, a buffer of capacity 1 is used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> BUFFERED: <span class="built_in">Int</span> = -<span class="number">2</span>  默认<span class="number">64</span></span><br></pre></td></tr></table></figure>

<p>也可以是自然数。</p>
<p><strong>要注意缓冲区为0不等于没有buffer修饰符的情况</strong>。当溢出策略为 suspend 的情况下，前者判断collect已消耗元素的标志是collect块开始处理，后者是collect块结束。<a href="https://stackoverflow.com/questions/65952256/kotlin-flow-buffer-capacity">一个buffer为0的案例</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
      <tags>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>Stutz&#39;s tools</title>
    <url>/2023/02/12/Stutz&#39;s%20tools/</url>
    <content><![CDATA[<p>乔纳·希尔在片尾重新声明了拍摄这部电影的原因：“我拍这部电影，因为想透过电影让更多人认识心理疗法，以及向大家推荐我在心理治疗中学到的工具；我拍这部电影，是因为我爱菲尔，是因为我爱这些工具让我拥有的生活。无论人们如何看待这部电影，对我来说重要的是我完成它了，我们一起，完成它了。”</p>
<p>第一个原因在片头出现过，后面的原因显然隐藏更深，也更私人化，影片的完成似乎也成为了希尔治愈自己的工具。说到治愈，想到了席安玛在某次《小妈妈》的采访中提到的一种说法。她希望《小妈妈》能够带给人们治愈，这同时也是电影和所有艺术作品的一个重要功能。</p>
<p>心理治疗是非常个人化的，也是一个漫长、复杂和相当需要专业性的过程，显然无法通过一部90分钟的纪录片完成。但希尔在片中用通俗易懂的方式介绍给了所有观众一些“工具”和理论，在此进行整理，也许可以帮助到有需要的朋友。</p>
<h3 id="1-激发自己的生命力（life-force）"><a href="#1-激发自己的生命力（life-force）" class="headerlink" title="1.激发自己的生命力（life force）"></a>1.激发自己的生命力（life force）</h3><p>如果你想要知道你该做什么，你是谁，你的人生使命，唯一的方法就是激发自己的生命力。唯有生命力，能在你迷失的时候引导你。你可以把它想象成一个三层的金字塔：最底层是你和你身体的关系；中间一层是你和其他人的关系；最上面是你和潜意识的关系。</p>
<p>和身体关系：你要做的就是让你的身体感觉更好，这通常是最有效的方式。具体包括三个方面：运动；饮食；睡眠。</p>
<p>和其他人的关系： 当一个人抑郁的时候，他会远离人际交往直到渐渐消失。而与其他人建立联系，会帮助你回到正常的生活。关键是你必须采取主动，不要别动等待。你可以邀请一个你不感情的人共进午餐，无所谓，一旦你这么做了，就会对你的状态产生积极的影响。</p>
<p>和潜意识的关系：你需要和你的潜意识建立联系。没有人知道自己的潜意识里有什么，除非你去激发它。有一个技巧是，你可以写下来，透过书写建立和自己潜意识的联系。不需要在意写下的是什么。如果你开始写作，写作就像一面镜子一样，会反映出你的潜意识里发生的事。如果你每天写，就会冒出很多你不知道自己在想的东西。</p>
<p>提升自己的生命力，你会发现你真正热爱的东西是什么。每个人都能做到以上这些。</p>
<p><img src="https://img2.doubanio.com/view/thing_review/l/public/p8226873.jpg"></p>
<h3 id="2-PART-X"><a href="#2-PART-X" class="headerlink" title="2.PART X"></a>2.PART X</h3><p>面对逆境时，你会直面part X。它是你身上充满批判性的一部分，非常反社会。它是一种无形的力量，想要阻止你改变或者成长，它想搞死你。它就像故事里的坏人，而“工具”则是战胜坏人的武器。 无论你想要做什么，Part X永远都在说：“不可能，放弃吧。”它会给你一份非常具体的报告，关于你是谁，你能做什么，它在你的身上制造一种原始的恐惧。</p>
<p>你永远无法完全摆脱Part X，你可以暂时打败它，但它会一直回来。因为只要身而为人，就永远无法逃离三个现实：痛苦、不确定性和永无止境的工作。  </p>
<p><img src="https://img9.doubanio.com/view/thing_review/l/public/p8226914.jpg" alt="图2:永远无法逃离的三个现实困境"><br>从另一方面说，我们需要Part X，否则我们就无法实现个人的成长。真正让你快乐的是战胜它的过程，你必须学会爱上处理以上三个现实困境的过程。人类创造力的最高表现，就是在逆境中开创新局。</p>
<h3 id="3-珍珠串（string-of-pearls）"><a href="#3-珍珠串（string-of-pearls）" class="headerlink" title="3.珍珠串（string of pearls）"></a>3.珍珠串（string of pearls）</h3><p> 你只需要画一串珍珠，画一条线，然后一个圈，再来一条线，再来一个圈。每个圈都等于一个行动，每个行动的价值都是平等的，我只用自己采取的行动来检视自己。无论失败还是成功，你都要继续往前。例如每天起床也是一个珍珠，起床后做的事情也是一个珍珠。不要赋予每个行动不同的价值。 真正的自信是活在不确定性中，永远继续前进。赢家不是那些总是做出最佳决定或者看起来最风光的人，而是愿意承担风险，秉持某种信念，并勇于承担结果的人。如果结果是不好的，也没有关系，继续前进，能做到这样是最好的。</p>
<p>在每个珍珠里，都有一个小黑点，这个黑点就是一颗粑粑。这就好像你所做的所有努力，最终结果都一定不是完美的，里面一定会有一颗粑粑。你并不要担心这颗粑粑是好的还是不好的，你只需要继续前进，把下一颗珍珠串到线上。</p>
<p><img src="https://img9.doubanio.com/view/thing_review/l/public/p8226986.jpg" alt="图3:珍珠串和粑粑"></p>
<h3 id="4-影子（the-shadow）"><a href="#4-影子（the-shadow）" class="headerlink" title="4.影子（the shadow）"></a>4.影子（the shadow）</h3><p>每个人都有影子，它就是人们感到羞耻的部分。你要做的第一件事情就是找到自己的影子，你必须将它影像化，看到它，才能专注于解决它。</p>
<p>-闭上眼睛，想象你人生中的某个时刻，你感到自卑、尴尬、沮丧、被拒绝、羞耻，你不要想承认这部分的自己，但你永远无法摆脱它。</p>
<p>-跟你的影子对话。问它对你以前处理它的方式有什么感觉？影子需要关注，它需要的不是外部的关注，而是你的关注。</p>
<p>-问它你需要如何弥补长久以来你对它缺乏关注的事实。</p>
<p>-睁开眼睛。</p>
<p>与影子对话是一个非常有效的工具，特别是在压力很大的时候。我们的目标是使用这个工具包容任何有可能出现的结果。如果我们能满意最真实的自己，其他人的看法将只会对我们产生非常小的影响。重点不是影子好不好看，重点是你需要持续和它产生连接。如果你不关注它，它会让你做出具有破坏性的事情。所以它既是一个工具，让你在当下感觉好受一些，也是一种哲学，告诉你自己将何去何从。与影子同步代表了一种完整，意味着我不需要其他东西就可以感受到一个完整的自我，这是一种非常自由的感受。</p>
<h3 id="5-快照（the-snapshot）"><a href="#5-快照（the-snapshot）" class="headerlink" title="5.快照（the snapshot）"></a>5.快照（the snapshot）</h3><p>快照也叫幻境，它也是part X的一部分。快照意味着你在寻找一次完美的体验，可能是一个完美的妻子，完美的存款数字，完美的电影等。它是什么并不重要，因为它实际上并不存在。它只是你脑海中的一个想象。</p>
<p>快照的本质什么？它是静止的，不会动，平面的，没有焦距。当你拍下这样的一张照片后，你会对着它幻想：如果我能进入这个完美的世界该多好，神奇的事情就会发生。但你不要忘了，永远有三样东西存在于我们的现实世界中：痛苦、不确定性和永无止境的工作。</p>
<p><img src="https://img1.doubanio.com/view/thing_review/l/public/p8232930.jpg" alt="图4:快照与现实"></p>
<h3 id="6-迷宫（the-Maze）"><a href="#6-迷宫（the-Maze）" class="headerlink" title="6.迷宫（the Maze）"></a>6.迷宫（the Maze）</h3><p>迷宫总是和其他人有关，它也是part X的一部分。它的产生来源于part X想要“公平”。最为典型的例子是，当你谈论另一个人时，你告诉自己：“只要他们做出弥补，我就会原谅他们。无论是他们对我生气，劈腿或是其他事情。”你感觉自己被亏待，而你对公平的追求让你的生活停摆了。</p>
<p>人生苦短，时间飞逝，你可能没有意识到，我们并没有时间浪费在这些破事儿上。大部分人，他们都希望得到补偿，他们希望所有的一切都是公平的，一切都是均衡的，但你往往无法从别人身上获得这些。你唯一能做的，是自己给予自己满足感，自己找回平衡。我们可以借助“主动的爱”这一工具走出迷宫。</p>
<p><img src="https://img2.doubanio.com/view/thing_review/l/public/p8232971.jpg" alt="图5:迷宫"></p>
<h3 id="7-主动的爱（active-love）"><a href="#7-主动的爱（active-love）" class="headerlink" title="7.主动的爱（active love）"></a>7.主动的爱（active love）</h3><p>-闭上眼睛，想象你被一个完全由爱组成的宇宙包围，我知道这听起来很疯狂，但试试吧。不要预设立场，我们一起看看会发生什么。</p>
<p>-我试着定义这个世界：这是一个几乎完全由爱的能量构成的世界，感觉自己吸收到了全宇宙的爱。现在，轻轻地，但稳稳地将所有的爱放进你心里。就在那一刻，你主导了全宇宙的爱。</p>
<p>-你现在要做的是，看到那个让你生气的人，那个你讨厌、你鄙视的人。你把你心中积聚的所有的爱传递给他。你毫无保留，你付出一切。你感觉到并且看到你的爱进入了对方的身体，这非常重要。从这一时刻开始，你们成为了一体。你感觉到：“如果我能和这个混蛋成为一体，那我可以和任何人成为一体。”这是一种无畏的感觉，几乎是征服感。</p>
<p>人们会说，你是在叫我去爱一个我讨厌的人。我想说，这并不是去原谅谁，这不是为了别人，这是为了让你感到完整，并且从迷宫中解脱出来。你想做一些正确的事情吗？你想创造一些什么吗？人生就是不断前进，如果你想浪费时间去玩迷宫游戏当然可以，但你会永远失去那些时间。</p>
<h3 id="8-感恩的心流（the-Greatful-Flow-）"><a href="#8-感恩的心流（the-Greatful-Flow-）" class="headerlink" title="8.感恩的心流（the Greatful Flow ）"></a>8.感恩的心流（the Greatful Flow ）</h3><p>你的每个想法都会影响你的心情，你的想法不是正面的就是负面的。感恩的心流想要选择正面的想法，而part X想要你有负面的心流，因此会形成乌云。有了乌云的存在，你会看不到太阳，以至于你忘记了太阳其实一直都在那里。问题是，你要如何穿过乌云？答案是：心怀感激。</p>
<p>感恩的心流会带给你一种流动感，让你觉得总有一些正面的东西存在，就算在当下你看不到它们。感恩的心流并不是某个你具体想感激的东西，它是创造这些东西的过程。</p>
<p>-闭上眼睛， 说出最多四个你要想感激的东西。这些东西越小越好，越小越容易让你聚焦。你要慢慢地去做这件事情，你要是去感受感恩。</p>
<p>-继续去想象你想感激的东西但不要说出来，继续创造感恩的心流。</p>
<p>-接下来，你会觉得自己要创造另一个感恩的想法，但你没有。你阻挡它，你只感觉到那股产生感恩想法的力量。当它变得越来越强烈，你会觉得自己被它占领。那就是感恩的心流。</p>
<p>重点不是一再重复说出你感激的东西，而是要把它变成一个创造性的行为。当你必须去发掘并且努力找到这些东西时，这个过程本身就会改变你的情绪。</p>
<p>使用这个工具的最佳时机是你的想法失去控制时。最糟糕的做法是跟它们争辩，那一点帮助也没有，只会造成更加可怕的后果。感恩并不仅是“我很开心，有人能够帮助我”，而是一种状态，一种你尽可能想要置身其中的状态。因为这个状态能连结你，帮助你穿过乌云，看到阳光。part X会说你不应该感恩，你是一个受害者，你得到的远远不够。这就是魔鬼的发言，这是非常典型的part X。</p>
<h3 id="9-丧失处理（loss-processing）"><a href="#9-丧失处理（loss-processing）" class="headerlink" title="9.丧失处理（loss processing）"></a>9.丧失处理（loss processing）</h3><p> 它是一个帮助你处理失去的工具，大部分人在处理这个主题时都表现得很差。他们表现得很差，不单是在失去的时候变得抑郁或者失落，而是在失去之前，他们就会担心失去。</p>
<p>这个工具的目标是获得不执着的力量，意味着我可以去追求某些东西，得不得到的话也没关系，我依然想要追求它，但我也愿意承担失去。</p>
<p>-首先，挑选一个你觉得自己过度执着的东西。 可能是一个人，一份工作，一个小东西，都无所谓。但必须是一个你不愿意放手的东西。你担心你一旦放手，糟糕的事情就会发生。</p>
<p>-现在，想象你抓着这个东西，如果它不是实在的物体也没有关系，只需要想象你抓着它，就像抓着一根树枝一样。你觉得很害怕，你不敢放手，但你还是放手了。</p>
<p>-你一旦放手，就开始坠落。这不是什么糟糕的感觉，出乎你的意料，坠落其实是一个缓慢而且温和的过程。在坠落的过程中，你对自己说：“我愿意失去一切。”你需要把这句话默默说出来，并思考它背后的意义。</p>
<p>-当你默默说出这句话时，你撞到了身下的太阳表面，你的身体开始燃烧。在那一刻，你失去了所有。因为你得有肉体才能拥有一切。要是你的肉体燃烧殆尽，你就只是其中的一个光束。你向四面八方辐射，你辐射出的都是充满爱、流动的能量。</p>
<p>-然后你环顾四周，你看到周围无数的太阳，就像你所在的那个，它们都在向外辐射。然后你听到所有的太阳都在说：我们无处不在。这个世界叫做太阳世界。</p>
<p>-你能做的就是付出，你不能索取，你不能抓住任何东西。现在，你可以睁开眼睛了。</p>
<p>另一种思维方式：你没有要变得不执着，你只是试着在每次害怕失去的时候试着不要执着。对大部分人来说，他们这辈子从来没有体验过不执着的感受。就算他能朝这个方向前进，也是有帮助的。 所以目标并不是完全变得不执着，而是努力不让失去一个人、地、物的经历完全夺走你的生活，以及你的完整感。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>行为建议</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread的UncaughtExceptionHandler</title>
    <url>/2023/02/06/Thread%E7%9A%84UncaughtExceptionHandler/</url>
    <content><![CDATA[<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mainFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> t = thread(start = <span class="literal">false</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;!!!!!&quot;</span>)</span><br><span class="line">        &#125;.apply &#123;</span><br><span class="line">            setUncaughtExceptionHandler &#123; thread, throwable -&gt;</span><br><span class="line">                println(<span class="string">&quot;child&quot;</span> + throwable.message)</span><br><span class="line">            &#125;</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Main&quot;</span> + e.message)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainFunction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">child!!!!!</span><br></pre></td></tr></table></figure>



<p>try catch不能捕获在trycatch括号内开的子线程抛出的异常，可以为线程设置一个 <code>UncaughtExceptionHandler</code>。</p>
<p>我联想到Coroutine中，try catch同样无法捕获括号内新开的<strong>子协程</strong>内抛出的错误，与之不同的是，协程的错误不是定义子协程的exception handler来处理，而是可以为TopLevelScope或Top level coroutine定义异常处理器。</p>
<p>参考资料：</p>
<p><a href="https://github.com/JeckOnly/passage/blob/master/Android/Kotin%20%E5%8D%8F%E7%A8%8B.md#1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">以前写的协程异常处理</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1652118">Java多线程捕获</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>今天去医院看了智齿</title>
    <url>/2023/02/06/%E4%BB%8A%E5%A4%A9%E5%8E%BB%E5%8C%BB%E9%99%A2%E7%9C%8B%E4%BA%86%E6%99%BA%E9%BD%BF/</url>
    <content><![CDATA[<p>今天和小云去医院看了智齿，然后给牙齿拍了一张2D的影片。医生说牙齿还是比较好的，没有什么问题。然后对于智齿那边有点疼的问题，医生说注意清淡饮食，少熬夜就可以，它们基本已经长出来了，还是比较平整的，不用拔，lucky:blush:</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>健康</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_50_螺旋矩阵</title>
    <url>/2023/02/09/leetcode-50-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>这道题看到很多解法都是边界法。然后看到另外一种有意思的解法。</p>
<p>用一个队列，储存四种 <strong>行为</strong>，即 event，这个行为不合法之后，循环下一个行为，直到行为的开始也不合法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ListNode <span class="keyword">import</span> ListNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 50</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        toDoList = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        result = []</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        errorNum = <span class="number">101</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        result.append(matrix[x][y]) <span class="comment"># 要先处理第一个数啦</span></span><br><span class="line">        matrix[x][y] = errorNum</span><br><span class="line">        temp = toDoList.pop(<span class="number">0</span>)</span><br><span class="line">        toDoList.append(temp)</span><br><span class="line">        toDoX = temp[<span class="number">0</span>]</span><br><span class="line">        toDOY = temp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ((x + toDoX &lt; m) <span class="keyword">and</span> (y + toDOY &lt; n) <span class="keyword">and</span> (matrix[x + toDoX][y + toDOY] != errorNum)):</span><br><span class="line">                temp = toDoList.pop(<span class="number">0</span>)</span><br><span class="line">                toDoList.append(temp)</span><br><span class="line">                toDoX = temp[<span class="number">0</span>]</span><br><span class="line">                toDOY = temp[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((x + toDoX &lt; m) <span class="keyword">and</span> (y + toDOY &lt; n) <span class="keyword">and</span> (matrix[x + toDoX][y + toDOY] != errorNum)):</span><br><span class="line">                    <span class="comment"># 新的开始都不合法了说明该结束了</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 下一个值合法</span></span><br><span class="line">                x += toDoX</span><br><span class="line">                y += toDOY</span><br><span class="line">                result.append(matrix[x][y])</span><br><span class="line">                matrix[x][y] = errorNum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    matric = [[<span class="number">1</span>]]</span><br><span class="line">    <span class="built_in">print</span>(solution.spiralOrder(matric))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>今天建站啦</title>
    <url>/2023/02/05/%E4%BB%8A%E5%A4%A9%E5%BB%BA%E7%AB%99%E5%95%A6/</url>
    <content><![CDATA[<p>今天把博客搭好啦！差不多搞了整整两天。</p>
<p>之前都在使用普通的Github仓库来存储技术博文，后来发现UI实在不够美观。</p>
<p>现在这个Hexo + Github Page搭建的博客有时间轴、标签、分类等，还有搜索功能~~:blush:</p>
<p>中途差点放弃，因为不熟悉遇到很多坑，想用WordPress等收费的可能会简单点（最后其实是因为那些更麻烦哈哈）</p>
<p>farewell!!</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>协程异常处理总结</title>
    <url>/2023/02/11/%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-Job的继承关系"><a href="#1-Job的继承关系" class="headerlink" title="1. Job的继承关系"></a>1. Job的继承关系</h3><p>首先来了解kotlin协程作用域的父子关系，parent-child。先来看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler3 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    topLevelScope.launch(exceptionHandler2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch(exceptionHandler3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个协程报错，然后try&#x2F;catch<strong>没有包裹报错的代码，而是包裹报错的那个协程</strong>，那么exception并不会被catch到，也就是协程里面的exception没有re-throw，而是propagated up，沿着job的继承链向上传递。下面是上面代码的父子协程关系图：</p>
<p><img src="https://i0.wp.com/www.lukaslechner.com/wp-content/uploads/2020/08/Screenshot-2020-08-25-at-10.51.22.png?w=792&ssl=1" alt="代码的协程继承关系"></p>
<ol>
<li><p>CoroutineScope是topLevelScope，第一个launch是Top-Level Coroutine，第二个和更多被它包裹住的算是Child Coroutine.</p>
</li>
<li><p>要判断继承关系需要看Job的继承，而不是看launch，不然会错过。CoroutineScope和launch中都有一个默认的Job参数作为Context。</p>
<p>这段话解读的很好：”To make all the features of Structured Concurrency possible, the <code>Job</code> object of a <code>CoroutineScope</code> and the <code>Job</code> objects of Coroutines and Child-Coroutines form a hierarchy of parent-child relationships. An uncaught exception, instead of being re-thrown, is “propagated up the job hierarchy”. This exception propagation leads to the failure of the parent <code>Job</code>, which in turn leads to the cancellation of all the <code>Job</code>s of its children.“</p>
</li>
</ol>
<h3 id="2-ExceptionHandler的位置"><a href="#2-ExceptionHandler的位置" class="headerlink" title="2. ExceptionHandler的位置"></a>2. ExceptionHandler的位置</h3><p>在上面的代码例子中，</p>
<p>1）如果exceptionHandler1和exceptionHandler2都在，那么exception上升到exceptionHandler2就被处理了，</p>
<p>2）如果exceptionHandler1和exceptionHandler2只有任意一个，那么就由存在的那个处理。</p>
<p>3）如果exceptionHandler1和exceptionHandler2都不在，那么就会去到<strong>线程的错误处理</strong>——crash。</p>
<p>4）在一个child coroutine中安装exceptionHandler没有效果。</p>
<p>总结：<strong>In order for a <code>CoroutineExceptionHandler</code> to have an effect, it must be installed either in the <code>CoroutineScope</code> or in a top-level coroutine.</strong></p>
<p>要么</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + coroutineExceptionHandler)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>要么</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">topLevelScope.launch(coroutineExceptionHandler) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在上面的那个例子中，由topLevelScope launch的<strong>其他顶层协程</strong>都因为一个顶层协程的报错而被取消，当然这个cancel是合作式的，仅仅是发出取消的指令。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">topLevelScope.launch() &#123;</span><br><span class="line">    <span class="comment">// 发生报错</span></span><br><span class="line">&#125;</span><br><span class="line">topLevelScope.launch &#123;<span class="comment">// 被取消</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)<span class="comment">// 合作式取消</span></span><br><span class="line">        println(<span class="string">&quot;循环打印&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-async的异常处理"><a href="#3-async的异常处理" class="headerlink" title="3.  async的异常处理"></a>3.  async的异常处理</h3><p>由async启动的协程的错误处理和launch有点不同。</p>
<h4 id="1-async启动的协程是Top-Level-协程"><a href="#1-async启动的协程是Top-Level-协程" class="headerlink" title="1.async启动的协程是Top-Level 协程"></a>1.async启动的协程是Top-Level 协程</h4><p>看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">       println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 顶层async</span></span><br><span class="line">   <span class="keyword">val</span> deferred = topLevelScope.async  &#123;</span><br><span class="line">       <span class="comment">// 发生报错</span></span><br><span class="line">       <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错既不会在async处 re-throw也不会上升到handler1处理，而是会在<strong>调用await()处</strong>被re-throw。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line"><span class="keyword">val</span> topLevelScope2 = CoroutineScope(exceptionHandler2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层async</span></span><br><span class="line"><span class="keyword">val</span> deferred = topLevelScope.async  &#123;</span><br><span class="line">    <span class="comment">// 发生报错</span></span><br><span class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topLevelScope2.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()<span class="comment">// re-throw here</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$e</span> in try/catch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>总结：这种情况，异常被封装在Deferred之中，只有在调用await处才会被re-throw。只需要在await()处调用try&#x2F;catch捕获。</p>
<h4 id="2-async启动的协程是Child协程"><a href="#2-async启动的协程是Child协程" class="headerlink" title="2.async启动的协程是Child协程"></a>2.async启动的协程是Child协程</h4><p>看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    <span class="keyword">val</span> topLevelScope2 = CoroutineScope(exceptionHandler2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deferred2: Deferred&lt;<span class="built_in">Nothing</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 顶层async</span></span><br><span class="line">    topLevelScope.launch  &#123;</span><br><span class="line">        deferred2 = async &#123;</span><br><span class="line">            <span class="comment">// 发生报错</span></span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topLevelScope2.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (deferred2 == <span class="literal">null</span>)</span><br><span class="line">                print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000</span>)</span><br><span class="line">            println(<span class="string">&quot;after 5 seconds&quot;</span>)</span><br><span class="line">            deferred2!!.await()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$e</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">800000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in handler1</span><br><span class="line">after 5 seconds</span><br><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>可以看到，async里面的报错，<strong>立即</strong>沿着Job继承链<strong>上升</strong>——propagated up，即使没调用await()，<strong>并且也会</strong>在await()处re-throw。</p>
<p>如果topLevelScope的exceptionHandler1被去掉，那么会crash，因为没有handler捕获这个上升的报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;DefaultDispatcher-worker-3&quot; java.lang.RuntimeException: RuntimeException in nested coroutine</span><br><span class="line">	at com.example.composeproject.TestKt$main$2$1.invokeSuspend(Test.kt:25)</span><br><span class="line">	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664)</span><br><span class="line">	Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine&#123;Cancelling&#125;@596502e1, Dispatchers.Default]</span><br><span class="line">after 5 seconds</span><br><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>总结：抛出异常后，</p>
<p>1）需要在Job链添加Handler捕获 </p>
<p>2）在await()处re-throw的异常也要捕获。</p>
<p>放一个表格总结一下对于Uncaught Exception(没有在协程体内被try&#x2F;catch的异常)的协程处理规律：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">launch</th>
<th align="center">async</th>
</tr>
</thead>
<tbody><tr>
<td align="center">top level Coroutine</td>
<td align="center">沿着Job上升</td>
<td align="center">被deferred包装，在await处re-throw</td>
</tr>
<tr>
<td align="center">child Coroutine</td>
<td align="center">沿着Job上升</td>
<td align="center">立刻沿着Job上升（即使不调用await），调用await时也re-throw</td>
</tr>
</tbody></table>
<h3 id="4-coroutineScope函数"><a href="#4-coroutineScope函数" class="headerlink" title="4. coroutineScope函数"></a>4. coroutineScope函数</h3><p>根据它的函数注释，提炼出一下要点：</p>
<ol>
<li><strong>Creates a CoroutineScope</strong> and calls the specified suspend block with this scope.</li>
<li>The provided scope inherits its coroutineContext from the outer scope, but <strong>overrides the context’s Job</strong>.</li>
<li>When any child coroutine in this scope fails, this scope fails and all the rest of the children are cancelled（内部block有结构化并发）</li>
<li>This function(is a <strong>suspend</strong> function) **returns as soon as the given block and all its children coroutines are completed.**（要注意，这是一个挂起函数，会阻塞调用它的协程，当它内部的结构化并发完成，这个函数才完成）</li>
<li>The method may throw a CancellationException if the current job was cancelled externally or may <strong>throw a corresponding unhandled Throwable</strong> if there is any unhandled exception in this scope (for example, from a crashed coroutine that was started with launch in this scope)（内部有异常，在这个函数调用处re-throw）</li>
</ol>
<p><strong>关键要注意的是，不要把它和 <code>CoroutineScope</code>、 <code>launch</code> 、 <code>async</code> 等启动顶层协程或子协程的非挂起函数搞混就行。</strong></p>
<p>换言之，不要被它的名字所误导，可以用try&#x2F;catch捕获它抛出的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + <span class="keyword">object</span>: CoroutineExceptionHandler &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">            <span class="keyword">get</span>() = CoroutineExceptionHandler.Key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            print(<span class="string">&quot;handle exception in coroutineexceptionhandler&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 没有try/catch就在CoroutineExceptionHandler捕获</span></span><br><span class="line">            coroutineScope &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-supervisorScope函数"><a href="#5-supervisorScope函数" class="headerlink" title="5.  supervisorScope函数"></a>5.  supervisorScope函数</h3><p>下面的代码建立了如下结构图</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>… will create the following job hierarchy:</p>
<p><img src="https://i0.wp.com/www.lukaslechner.com/wp-content/uploads/2020/08/Screenshot-2020-08-25-at-11.19.55.png?w=786&ssl=1"></p>
<p>性质和 <code>coroutineScope</code> 很类似</p>
<ol>
<li>这是一个挂起函数，会阻塞调用它的协程，当它内部的结构化并发完成，这个函数才完成</li>
</ol>
<h4 id="1-内部启动的launch-x2F-async都是-top-level-coroutine"><a href="#1-内部启动的launch-x2F-async都是-top-level-coroutine" class="headerlink" title="1. 内部启动的launch&#x2F;async都是 top-level coroutine."></a>1. 内部启动的launch&#x2F;async都是 <code>top-level</code> coroutine.</h4><p>This also means we can now install a <code>CoroutineExceptionHandler</code> in them that is actually called:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$exception</span> in CoroutineExceptionHandler&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch(coroutineExceptionHandler) &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Exception in Coroutine 2&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: Exception in Coroutine 2 in CoroutineExceptionHandler</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure>

<p>The fact that coroutines that are started directly in <code>supervisorScope</code> are <strong>top-level Coroutines</strong> also means that <code>async</code> Coroutines now encapsulate their exceptions in their <code>Deferred</code> objects …(3.1节的情况)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... other code is identical to example above</span></span><br><span class="line">supervisorScope &#123;</span><br><span class="line">    <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">        println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Exception in Coroutine 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: </span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure>

<p>… and will only be re-thrown when calling <code>.await()</code></p>
<h4 id="2-supervisorScope的一些报错逻辑"><a href="#2-supervisorScope的一些报错逻辑" class="headerlink" title="2. supervisorScope的一些报错逻辑"></a>2. supervisorScope的一些报错逻辑</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子协程异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">            delay(<span class="number">6000</span>)</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException()<span class="comment">// 不影响 1）Job3 2）supervisorScope块 的代码</span></span><br><span class="line">                println(<span class="string">&quot;Coroutine 2 end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">                delay(<span class="number">4000</span>)</span><br><span class="line">                println(<span class="string">&quot;Coroutine 3 end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            delay(<span class="number">5000</span>)</span><br><span class="line">            println(<span class="string">&quot;supervisorScope end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">80000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本身supervisorScope block异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">            delay(<span class="number">6000</span>)</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            supervisorScope &#123;</span><br><span class="line">                <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                    println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                    delay(<span class="number">3000</span>)</span><br><span class="line">                    println(<span class="string">&quot;Coroutine 2 end&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                    println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">                    delay(<span class="number">4000</span>)</span><br><span class="line">                    println(<span class="string">&quot;Coroutine 3 end&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                delay(<span class="number">2000</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;supervisorScope block exception&quot;</span>)<span class="comment">// 1） fails the scope with all its children 2）在supervisorScope函数调用处re-throw</span></span><br><span class="line">                delay(<span class="number">6000</span>)</span><br><span class="line">                println(<span class="string">&quot;supervisorScope end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;catch excception <span class="subst">$&#123;e.message&#125;</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">80000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<table>
<thead>
<tr>
<th>内部开的协程异常</th>
<th>block块抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>由于是顶层协程，可以给它们设置ExceptionHandler</td>
<td>会在supevisorScope函数调用处re-throw</td>
</tr>
</tbody></table>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><h4 id="1。破坏Job链继承导致ExceptionHandler处理者改变"><a href="#1。破坏Job链继承导致ExceptionHandler处理者改变" class="headerlink" title="1。破坏Job链继承导致ExceptionHandler处理者改变"></a>1。破坏Job链继承导致ExceptionHandler处理者改变</h4><p><a href="https://jeckonly.github.io/2023/02/07/%E5%AD%90%E5%8D%8F%E7%A8%8B%E4%B8%8D%E8%A2%AB%E7%88%B6%E5%8D%8F%E7%A8%8B%E5%BD%B1%E5%93%8D%E7%9A%84%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5/">子协程不被父协程影响的例外情况</a></p>
<p>我之前写有文章说过这种情况。如果child coroutine的Job是显式定义一个Job()，那么它不能算是“child coroutine”了，因为它不参与它parent的结构化并发，那么在下面的代码中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler3 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    topLevelScope.launch(exceptionHandler2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch(exceptionHandler3 + Job()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in handler3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>子协程不被父协程影响的例外情况</title>
    <url>/2023/02/07/%E5%AD%90%E5%8D%8F%E7%A8%8B%E4%B8%8D%E8%A2%AB%E7%88%B6%E5%8D%8F%E7%A8%8B%E5%BD%B1%E5%93%8D%E7%9A%84%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>协程中的所谓 <strong>结构化并发</strong>，就是指 <strong>父协程和子协程一起有组织有预谋地合作干活</strong>，如果不讨论<code>scupervisorScope&#123;&#125;</code>的话，大致上内涵如下：</p>
<ol>
<li>子协程fail——报错，父协程和其他子协程都cancel.</li>
<li>子协程cancel，父协程和其他子协程<strong>没事</strong>。</li>
<li>父协程fail，它所有子协程cancel。</li>
<li>父协程cancel，它所有子协程cancel。</li>
</ol>
<blockquote>
<p>子协程指<code>CoroutineScope</code>.launch&#x2F;async调用的结果。为避免混乱，不讨论 <code>coroutineScope</code>\ <code>supervisorScope</code>。</p>
</blockquote>
<p><a href="https://gist.github.com/JeckOnly/646ee60e16591468c405f59d8245880d">上面四个情况的案例</a></p>
<p>但也有例外，</p>
<p>当一个协程被其它协程在 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中启动的时候， 它将通过 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html">CoroutineScope.coroutineContext</a> 来承袭上下文(除了Job会是一个新实例，其他的例如调度器都继承下来)，并且这个新协程的 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 将会成为父协程作业的子Job。当一个父协程被取消的时候，所有它的子协程也会被递归的取消。</p>
<p>However, this parent-child relation can be explicitly overriden in one of two ways:</p>
<ol>
<li>When a different scope is explicitly specified when launching a coroutine (for example, <code>GlobalScope.launch</code>), then it does not inherit a <code>Job</code> from the parent scope.</li>
<li>When a different <code>Job</code> object is passed as the context for the new coroutine (as shown in the example below), then it overrides the <code>Job</code> of the parent scope.</li>
</ol>
<p>In both cases, the launched coroutine is not tied to the scope it was launched from and operates independently.</p>
<p>第一种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// 一个TopLevelScope</span></span><br><span class="line">        CoroutineScope(context = Dispatchers.Default).launch &#123;</span><br><span class="line">            println(<span class="string">&quot;NewTopLevelScope job1: I run in my own Job and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;NewTopLevelScope job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 另一个则承袭了父协程的上下文</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;ChildCoroutine job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;ChildCoroutine job2: I will not execute this line if my parent request is cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// 取消请求（request）的执行</span></span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 主线程延迟一秒钟来看看发生了什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">NewTopLevelScope job1: I run <span class="keyword">in</span> my own Job and execute independently!</span><br><span class="line">ChildCoroutine job2: I am a child of the request coroutine</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">NewTopLevelScope job1: I am not affected <span class="keyword">by</span> cancellation of the request</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// 生成了两个子作业</span></span><br><span class="line">        launch(Job()) &#123;</span><br><span class="line">            println(<span class="string">&quot;job1: I run in my own Job and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 另一个则承袭了父协程的上下文</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I will not execute this line if my parent request is cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// 取消请求（request）的执行</span></span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 主线程延迟一秒钟来看看发生了什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">job1: I run <span class="keyword">in</span> my own Job and execute independently!</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">job1: I am not affected <span class="keyword">by</span> cancellation of the request</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>要注意，无论如何，子协程的Job都是一个新实例，和Parent的Job不是同一个实例。我想区别在于 <strong>隐式创建时</strong> 带上了一些父子协程的信息。</p>
<p>参考资料：<a href="https://book.kotlincn.net/text/coroutine-context-and-dispatchers.html">协程上下文和调度器</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>小云第一局Valorant</title>
    <url>/2023/02/06/%E5%B0%8F%E4%BA%91%E7%AC%AC%E4%B8%80%E5%B1%80Valorant/</url>
    <content><![CDATA[<p>小云今天完完整整地打了一局Valorant，之前都是零零碎碎地打。不得不说对于一个新手来说，还行。不过我们也是今天她玩了才知道她晕三D，她说吃饭时都没啥胃口。我也是第一次实际看到晕三D的情况。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>小云</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>最近关于多巴胺的一点思考</title>
    <url>/2023/02/07/%E6%9C%80%E8%BF%91%E5%85%B3%E4%BA%8E%E5%A4%9A%E5%B7%B4%E8%83%BA%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>我想多巴胺可以根据如何触发的分为 内源性多巴胺和外源性多巴胺。内源性多巴胺是在完成了一些困难的任务，或相对的来说和如今的触手可及的娱乐活动相比“不那么愉悦”的活动，或经历了伤痛之后，大脑为了恢复pleasure \ pain的平衡而分泌的多巴胺。外源性的多巴胺则是在“上瘾”的驱动下释放的多巴胺，比如吃巧克力，玩电子游戏（注意，这些活动对一些人来说可能如工作一般乏味，我指的是对认为它们具有巨大诱惑力的人来说）。外源性的多巴胺往往在短时间内可以让人获得比较大的愉悦，但过后往往是痛苦，并且还会有更深层次的危险——在生理层面上改变大脑对快乐和痛苦的感受，使得痛苦越来越敏感，快乐需要更大的刺激才能达到以前小小的刺激就可以达到的水平；在日常状态下，大脑中快乐和痛苦的“跷跷板”不是趋于平衡，而是限于水平之下，即忧郁和焦虑。这也是《Dopamine Nation》的作者认为现代人普遍焦虑、抑郁和失眠的原因。</p>
<blockquote>
<p>人类有接近快乐和避免痛苦的习惯。这是一种本能，可以追溯到数百万年前，那时人们需要每天积极寻找食物、衣服和住所，否则就会面临死亡风险。</p>
<p>但是精神病学家安娜·伦布克他说，在当今世界，这样的基本需求往往是现成的，这改变了等式。</p>
</blockquote>
<p>诱惑太多，释放外源性多巴胺对于现代人来说过于容易，这也改变了大脑的快乐痛苦平衡。</p>
<blockquote>
<p><strong>关于大脑中快乐和痛苦处理是如何重叠的</strong></p>
<p>过去75年来，神经科学最令人着迷的发现之一是，大脑中处理快乐的相同区域也处理痛苦，快乐和痛苦就像一种平衡。所以，如果你想象一下，在你的大脑中有一个跷跷板，就像你在孩子们的操场上看到的一样，当摇摇晃荡的东西处于静止基线时，它与地面是平的。当我们做一些令人愉快的事情时——例如，当我吃一块巧克力时——我的快乐&#x2F;痛苦平衡会稍微偏向快乐的一边，我的大脑的奖赏途径中会释放多巴胺。</p>
<p>但调节这种平衡的一个主要原则是，它希望保持水平，这就是神经科学家所说的 <strong>稳态</strong> 它不想偏离太长时间，无论是快乐还是痛苦。因此，当我吃一块巧克力时，我的大脑会立即适应这种愉悦刺激的存在，<strong>将我的平衡倾斜到与疼痛等量相反的一边</strong>。这就是后遗症或衰退，或者在我的情况下，想要第二块巧克力的那一刻。现在，如果我<strong>等待足够长的时间</strong>，这种感觉就会消失，体内平衡也会恢复。</p>
<p><strong>当快乐迅速变成痛苦或不适时</strong></p>
<p>当这种快乐&#x2F;痛苦的平衡在快乐的体验之后倾斜到痛苦的一边时，痛苦是作为许多不同的事物被主观体验的。其中之一是一种不舒服、不安、易怒、不快乐的主观感觉，以及想要重新创造快乐的感觉。但在很多方面，这也是渴望的含义：想要得到快乐，再次，全神贯注于消除我们在事后感受到的痛苦体验。我也会说，这是非常自反的。我甚至没有意识到这种后果或衰落。这可能很微妙，但我只是有点想再吃一块巧克力。</p>
</blockquote>
<p>突然想到了所谓的“男人事后一根烟”，sex行为使得多巴胺水平快速升高，而在疯狂的愉悦过后，快感消退，大脑为了恢复稳态，让“跷跷板”倾向于痛苦一侧。反映在主观感受上可能就是一种落寞和空虚吧。我想还有很多其他例子，最“臭名昭著”的莫过于短视频和电子游戏了。女朋友和我说，在刷很长一段时间的B站后（根本停不下来），会觉得精神很疲惫，然后负罪感很强，一开始刚刷的时候停不下来的兴奋不见了，反而是一种轻抑郁的状态。</p>
<p>我想这对于每一个现代人来说都是一个严肃的问题。有趣的是，我发现现代的很多生理学研究成果证明了很多古代先贤的哲学思想的正确性。比如说佛教的，有什么“俗世间的享乐都是镜中花水中月”，古希腊的斯多葛主义学派：快乐和痛苦都不会长久，安宁（平静）才是我们追求的首要目标，犬儒学派：限制你的生活条件，减少享乐，反而可以带来由衷的快乐。诸如此类。</p>
<p>有关这一方面的更多知识，可以看 <strong>《Dopamine Nation》</strong>这本书，也有关于这本书的访谈视频，可以在网上搜搜看。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>行为建议</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：IntelliJ调试协程</title>
    <url>/2023/02/08/%E8%BD%AC%E8%BD%BD%EF%BC%9AIntelliJ%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Debug-coroutines-using-IntelliJ-IDEA-–-tutorial"><a href="#Debug-coroutines-using-IntelliJ-IDEA-–-tutorial" class="headerlink" title="Debug coroutines using IntelliJ IDEA – tutorial"></a>Debug coroutines using IntelliJ IDEA – tutorial</h1><p>Last modified: 07 February 2023</p>
<p>This tutorial demonstrates how to create Kotlin coroutines and debug them using IntelliJ IDEA.</p>
<p>The tutorial assumes you have prior knowledge of the <a href="https://kotlinlang.org/docs/coroutines-guide.html">coroutines</a> concept.</p>
<h2 id="Create-coroutines"><a href="#Create-coroutines" class="headerlink" title="Create coroutines"></a>Create coroutines</h2><ol>
<li><p>Open a Kotlin project in IntelliJ IDEA. If you don’t have a project, <a href="https://kotlinlang.org/docs/jvm-get-started.html#create-a-project">create one</a>.</p>
</li>
<li><p>To use the <code>kotlinx.coroutines</code> library in a Gradle project, add the following dependency to <code>build.gradle(.kts)</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>For other build systems, see instructions in the <a href="https://github.com/Kotlin/kotlinx.coroutines#using-in-your-projects"><code>kotlinx.coroutines</code> README</a>.</p>
<blockquote>
<p>我的Coroutine版本是最新，但是Kotlin版本不是最新，而是1.6.24，结果调试器有问题，我更改到1.8.10最新版就可以了。</p>
</blockquote>
</li>
<li><p>Open the <code>Main.kt</code> file in <code>src/main/kotlin</code>.</p>
<p>The <code>src</code> directory contains Kotlin source files and resources. The <code>Main.kt</code> file contains sample code that will print <code>Hello World!</code>.</p>
</li>
<li><p>Change code in the <code>main()</code> function:</p>
<ul>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html"><code>runBlocking()</code></a> block to wrap a coroutine.</li>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html"><code>async()</code></a> function to create coroutines that compute deferred values <code>a</code> and <code>b</code>.</li>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html"><code>await()</code></a> function to await the computation result.</li>
<li>Use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/println.html"><code>println()</code></a> function to print computing status and the result of multiplication to the output.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> a = async &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m computing part of the answer&quot;</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = async &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m computing another part of the answer&quot;</span>)</span><br><span class="line">        <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;The answer is <span class="subst">$&#123;a.await() * b.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>Build the code by clicking <strong>Build Project</strong>.</p>
<p><img src="https://kotlinlang.org/docs/images/flow-build-project.png" alt="Build an application"></p>
</li>
</ol>
<h2 id="Debug-coroutines"><a href="#Debug-coroutines" class="headerlink" title="Debug coroutines"></a>Debug coroutines</h2><ol>
<li><p>Set breakpoints at the lines with the <code>println()</code> function call:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-breakpoint.png" alt="Build a console application"></p>
</li>
<li><p>Run the code in debug mode by clicking <strong>Debug</strong> next to the run configuration at the top of the screen.</p>
<p><img src="https://kotlinlang.org/docs/images/flow-debug-project.png" alt="Build a console application"></p>
<p>The <strong>Debug</strong> tool window appears:</p>
<ul>
<li>The <strong>Frames</strong> tab contains the call stack.</li>
<li>The <strong>Variables</strong> tab contains variables in the current context.</li>
<li>The <strong>Coroutines</strong> tab contains information on running or suspended coroutines. It shows that there are three coroutines. The first one has the <strong>RUNNING</strong> status, and the other two have the <strong>CREATED</strong> status.</li>
</ul>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-1.png" alt="Debug the coroutine"></p>
</li>
<li><p>Resume the debugger session by clicking <strong>Resume Program</strong> in the <strong>Debug</strong> tool window:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-2.png" alt="Debug the coroutine"></p>
<p>Now the <strong>Coroutines</strong> tab shows the following:</p>
<ul>
<li>The first coroutine has the <strong>SUSPENDED</strong> status – it is waiting for the values so it can multiply them.</li>
<li>The second coroutine is calculating the <code>a</code> value – it has the <strong>RUNNING</strong> status.</li>
<li>The third coroutine has the <strong>CREATED</strong> status and isn’t calculating the value of <code>b</code>.</li>
</ul>
</li>
<li><p>Resume the debugger session by clicking <strong>Resume Program</strong> in the <strong>Debug</strong> tool window:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-3.png" alt="Build a console application"></p>
<p>Now the <strong>Coroutines</strong> tab shows the following:</p>
<ul>
<li>The first coroutine has the <strong>SUSPENDED</strong> status – it is waiting for the values so it can multiply them.</li>
<li>The second coroutine has computed its value and disappeared.</li>
<li>The third coroutine is calculating the value of <code>b</code> – it has the <strong>RUNNING</strong> status.</li>
</ul>
</li>
</ol>
<p>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>远离使杀戮更容易</title>
    <url>/2023/02/10/%E8%BF%9C%E7%A6%BB%E4%BD%BF%E6%9D%80%E6%88%AE%E6%9B%B4%E5%AE%B9%E6%98%93/</url>
    <content><![CDATA[<p>原文</p>
<hr>
<p>在弗兰克·赫伯特（Frank Herbert）的经典科幻小说《沙丘》中，主人公必须压制他当下的动物本能，以此来证明自己是人类。他的手被放在一个邪恶的装置——一个会产生剧痛的黑盒子里。如果他把手从盒子里抽出来，负责看守的老妇人就会用毒针刺穿他的脖子，他就会死。她告诉他：“你听说过动物为了逃离陷阱而咬断自己一条腿的事吗？那是动物的把戏。如果是一个人，他会一直待在陷阱里，忍受痛苦，假装死亡，这样他才有可能杀死捕猎者，并消除对他的同类的威胁。”</p>
<p>有些人天生比其他人更善于抑制情绪。事实上，这是与生俱来的，部分原因是他们的多巴胺受体的数量和性质异于常人。多巴胺受体是大脑中的分子，它们在多巴胺释放时会做出响应。遗传特征不同，多巴胺受体的情况也会有所差异。研究人员测量了不同人大脑中多巴胺受体的密度（受体的数量，以及它们之间距离的远近），并将其与这些人的“情绪分离”测量结果进行了比较。<br>情绪分离测试测量了一个人避免分享个人信息、避免与他人交往的倾向等特征。科学家们发现受体密度和与他人接触的倾向有直接关系，高密度的多巴胺受体与高水平的情绪分离有关。在另一项研究中，情绪分离得分最高的人将自己描述为“在人际关系中冷漠、社交冷淡、有报复心”。相比之下，情绪分离度最低的人则将自己描述为“过于热情、易被人利用”。</p>
<p>大多数人的情绪分离程度介于最高和最低之间。我们既不冷漠也不会热情过度，我们的反应取决于具体情况。如果我们与周围的人在近体空间接触——靠得很近，直接接触，专注于此刻——当下分子回路会被激活，我们性格中温暖、热情的一面就会显现出来。而如果我们在远体空间跟人打交道——保持距离，抽象思考，专注于未来——我们性格中理性、克制的部分就更容易被看到。这两种不同的思维方式可以用“电车问题”来说明：</p>
<p>一列失控的火车沿着铁轨疾驰而下，驶向5名工人。如果什么都不做，他们都会死。然而，把一个旁观者推向铁轨是有可能阻止火车的前进的。这个人的死会使火车减速，足以拯救5个工人的生命。你会把这个人推向铁轨吗？</p>
<p>在这种情景下，大多数人都不会将这个旁观者推向轨道——他们无法亲手杀死一个人，即使是为了拯救5个人的生命。当下神经递质负责产生对他人的同理心，在大多数人身上，它都会压倒多巴胺精于盘算的理性。在这种情况下，当下的反应是如此强烈，因为旁观者离得太近，就在<strong>近体空间</strong>。要杀死他，我们必须用手接触他。除了最冷漠的人，其他人都做不到。</p>
<p>但是，既然<strong>当下分子最强大的影响是在近体空间</strong>（我们五官所感知的当下世界），如果我们一步一步地后退，逐步减少当下分子对我们决策的影响，会发生什么？当我们离开当下分子的近体空间进入<strong>多巴胺能的远体空间</strong>时，我们用一条生命换5条生命的意愿是否会增加？</p>
<p>让我们先从消除身体接触的当下感觉开始。想象一下，你站在一段距离之外看着事态发展。有一个开关，拉动它，就可以将列车从有5个人的轨道转移到只有一个人的轨道；而如果什么都不做，那5个人就会死。你会拉动开关吗？</p>
<p>下面进一步把自己拉远。想象一下，你坐在距离遥远的另一座城市的办公桌旁。电话铃响了，一个语无伦次的铁路工人描述了这个情况。你在办公桌前就可以控制火车的行进路线。你可以按下一个开关，让火车转向只有一个人在上面的轨道，或者什么也不做，让火车撞向5个人。你会按下开关吗？</p>
<p>最后，我们考虑最抽象的情况：抛弃所有的当下分子，让大脑完全为多巴胺掌控。假设你是一名运输系统工程师，正在设计铁路轨道的安全特性。你在铁轨旁安装了摄像头，能够准确提供实时的信息。你需要写一个控制开关的计算机程序，该程序将使用摄像机拍下的信息来选择让火车通过哪个轨道。你会将这个软件设定为为了救5个人而杀死一个人吗？</p>
<p>以上几种场景各异，但结果是一样的：牺牲一条生命换取5条生命，或者牺牲5条生命挽救一个人。很少有人会愿意牺牲一个无辜的人，把他推向死亡。然而，如果是写一个管理轨道开关的软件来使生命损失最小化，就很少有人会犹豫了。这就好像有两个不同的人在评估情况：一个人的头脑是理性的，只根据理性来做决定；另一个人富有同情心，不管大局如何，都不愿杀人。一个人试图通过拯救最多的人来控制局势，另一个则不会。我们会选择哪个结果，在一定程度上取决于多巴胺回路中的活动。</p>
<hr>
<p>在了解到大脑对判断为属于 <strong>近体空间</strong> 的事件和属于 <strong>远体空间</strong> 的事件会产生截然不同的情绪和处理方法（理性还是非理性）之后，我联想到许久以前看过的一本有关藏传佛教的书。</p>
<p>书中简述了一种 “放下” 的状态，一种不执著于当下，不困于痛苦，也不困于兴奋的一种超脱的状态，要达到这种状态，首先要放下对“我”的执着，类似于无我。如果一个人有焦虑，抑郁等情绪，这种状态应该是他所求之不得的。而实践时的方法则是：想象自己不是自己，以一个旁观者的角度来看自己的肉体，看自己遇上的事件，当自己逐渐越来越不以 <strong>遭遇者</strong> 的身份去体验不好的事情，而是以 <strong>旁观者</strong>的身份去看待事情的话——便能放下。</p>
<p>没想到原来这还有脑科学的依据，我一直以为这只是一种心理学技巧。</p>
<p>常听有人说，看科幻小说、电影等看多了，想像宇宙的宏大、人生的短暂、人类的渺小，不自觉地感到生活的不顺心似乎也没有什么值得在意，情绪变得平静。这其实也是一种从 <strong>远体空间</strong> 看事物所带来的结果吧。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>情绪控制</tag>
      </tags>
  </entry>
</search>
