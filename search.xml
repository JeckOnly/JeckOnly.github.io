<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>After reading The Little Prince</title>
    <url>/2023/02/14/After%20reading%20The%20Little%20Prince/</url>
    <content><![CDATA[<p>I finished reading ‘The Little Prince’ from last night to this afternoon. It’s my first time finishing an entire book in English. Even though there were many words I didn’t know, I didn’t give up. </p>
<p>After reading the last page, I felt a little tired but delighted with the job I had done. I believe that if I continue to read English books, I can gradually improve my English proficiency.</p>
<p>The last time I read this book was almost a few years ago, and since then, so many things have happened. After reading the last page, many thoughts filled my mind. This book made me think about dreams, work, money, and so on.</p>
<p>Thanks ChatGpt for correcting my grammar.</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>After watching Shutter Island</title>
    <url>/2023/02/20/After%20watching%20Shutter%20Island/</url>
    <content><![CDATA[<ul>
<li><p>How we doing this morning?</p>
</li>
<li><p>Good. And you?</p>
</li>
<li><p>Can’t complain.</p>
</li>
<li><p>So what’s our next move?</p>
</li>
<li><p>You tell me.</p>
</li>
<li><p>We gotta get off this rock, chuck.Get back to the mainland.Whatever the hell’s going on here, it’s bad.</p>
</li>
<li><p>……</p>
</li>
<li><p>Dont worry, partner, they’re not gonna catch us.</p>
</li>
<li><p>That’s right. We’re too smart for them.</p>
</li>
<li><p>Yeah, we are, aren’t we?</p>
</li>
<li><p>……</p>
</li>
<li><p>You know, this place makes me wonder…</p>
</li>
<li><p>Yeah, what’s that, boss?</p>
</li>
<li><p>Which would be worse, to live as a monster or to die as a good man?</p>
</li>
<li><p>Teddy?</p>
</li>
</ul>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>Android存储系统概况</title>
    <url>/2023/02/24/Android%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%86%B5/</url>
    <content><![CDATA[<p>在api 28 29 30 31 33都进行测试过。</p>
<p>&#x2F;是根目录</p>
<ol>
<li>&#x2F;data&#x2F;data&#x2F;com.xxx.xxx&#x2F;…</li>
<li>首先 &#x2F;sdcard&#x2F;、&#x2F;storage&#x2F;self&#x2F;primary&#x2F; 真正指向的是&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;，所以用x表示这三者。x&#x2F;Android&#x2F;data&#x2F;com.xxx.xxx&#x2F;…</li>
<li>x&#x2F;[DCIM, Alarm, Pictures]</li>
<li>x下其他目录，比如  x&#x2F;qq</li>
</ol>
<p>1、2都是特定应用的，特点是路径有包名。这两个目录本App无需申请访问权限即可申请，其它App也无法访问本App的目录。</p>
<p>1称为 internal storage，2称为 external storage的应用专属目录。</p>
<p>3我称之为 external public storage。</p>
<p>4称之为其他目录</p>
<p>1、2不受分区存储影响。</p>
<p>4我不会。</p>
<p>在本文就研究对于<strong>3</strong>受<strong>分区存储</strong>的影响（表现在<strong>9以前，10，11以后</strong>这三个版本不同）</p>
<p>各个版本对于external public的不同反应</p>
<table>
<thead>
<tr>
<th></th>
<th>9 以下</th>
<th>10</th>
<th>11 以上</th>
</tr>
</thead>
<tbody><tr>
<td>增</td>
<td>需要写权限</td>
<td>不需要权限</td>
<td>不需要权限</td>
</tr>
<tr>
<td>删</td>
<td>需要写权限。本应用和其他应用都可删</td>
<td>不需要权限，但只能删自己；删其他应用需要在弹出的Dialog确认</td>
<td>不需要权限，但只能删自己；删其他应用需要在弹出的Dialog确认</td>
</tr>
<tr>
<td>查</td>
<td>需要读权限。本应用和其他应用都可查</td>
<td>不需要权限，但只能查自己；有权限后，本应用和其他应用都可查</td>
<td>不需要权限，但只能查自己；有权限后，本应用和其他应用都可查</td>
</tr>
</tbody></table>
<p><strong>申请权限跑我那个函数就行。</strong>适配到Api33。</p>
<blockquote>
<p>9以下好像在多少版本以前，是在Manifest声明READ,,,和WRITE就行，之后才是运行时请求。不想不区分这个，9以下就运行时请求就对了，有的话就直接通过了，不用区分。</p>
</blockquote>
<p>我写了一套函数，用于操作 1 2 3 区域(目前只是Image，本文讲的都是 <strong>媒体文件</strong>，txt等文档需要用SAF，去下面官网链接看看)，这些函数都是全版本适用的，向后（backward）兼容。</p>
<p>参考</p>
<p><a href="https://juejin.cn/post/7012108220982362149">juejin</a></p>
<p><a href="https://developer.android.com/training/data-storage/app-specific?hl=zh-cn">不怎么的官网</a></p>
<p><a href="https://www.youtube.com/watch?v=TkOzcyzH1hU&list=PLQkwcJG4YTCR9jZq8O19nUL2hLqmLYX4M&ab_channel=PhilippLackner">Philipp系列视频</a></p>
<p><a href="https://github.com/JeckOnly/StorageDemo">最后附上我的demo</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用数据和文件</category>
      </categories>
  </entry>
  <entry>
    <title>Flow异常处理</title>
    <url>/2023/02/09/Flow%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>它们的函数注释一言难尽，建议别看，onCompletion的注释不太对。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;0 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;1 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .collect()<span class="comment">// 声明式写法，collect代码块内容写在onEach中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line"></span><br><span class="line">Got <span class="number">1</span></span><br><span class="line"><span class="number">0</span> Done fail</span><br><span class="line"><span class="number">1</span> Done fail</span><br><span class="line"><span class="number">1</span> <span class="keyword">catch</span> java.lang.IllegalStateException: Crash on <span class="number">2</span></span><br><span class="line"><span class="number">2</span> Done successfully</span><br></pre></td></tr></table></figure>



<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><ol>
<li>只能捕捉到上游的异常，下游无法（所以它<strong>根本不能捕获终端操作符中抛出的异常</strong>）。</li>
<li>只有捕捉到异常，才进入代码块。</li>
<li>可以抛出其他异常</li>
<li>可以emit值</li>
</ol>
<h3 id="onCompletion"><a href="#onCompletion" class="headerlink" title="onCompletion"></a>onCompletion</h3><p>这个有点复杂，分情况讨论。</p>
<h4 id="正常结束"><a href="#正常结束" class="headerlink" title="正常结束"></a>正常结束</h4><ol>
<li>onCompletion操作符按声明顺序，依次进入其代码块执行，异常参数为null</li>
<li>可以emit值</li>
</ol>
<h4 id="异常结束"><a href="#异常结束" class="headerlink" title="异常结束"></a>异常结束</h4><p>异常结束的时候，一个onCompletion操作符异常参数依然有可能为null。</p>
<ol>
<li>为null的情况是：<strong>该操作符和异常抛出处之间（注意之间），有catch捕获了该异常，且catch没有抛出异常，且终端操作符没有抛出异常。</strong></li>
<li>其他情况，异常参数都不为null。</li>
</ol>
<p><strong>当异常参数不为null的情况下（不管它正常结束还是异常结束）才可以在代码块中emit值。</strong></p>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;0 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 0</span></span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;1 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            emit(<span class="number">100</span>)</span><br><span class="line">        &#125;<span class="comment">// 1</span></span><br><span class="line">        .<span class="keyword">catch</span> &#123; cause: Throwable -&gt;</span><br><span class="line">            println(<span class="string">&quot;1 catch <span class="subst">$&#123;cause&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done successfully&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;2 Done fail&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 3</span></span><br><span class="line">        .collect&#123;&#125;<span class="comment">// 声明式写法，collect代码块内容写在onEach中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例已异常结束，0&#x2F;1处异常参数不为空，2处为空（catch把它捕获了）。</p>
<p><strong>如果终端有异常，所有onCompletion操作符异常参数都不为空。</strong></p>
<p>另外，catch和onCompletion的执行顺序按照<strong>声明顺序</strong>（如果某catch可以执行的话）。</p>
<h3 id="声明式写法"><a href="#声明式写法" class="headerlink" title="声明式写法"></a>声明式写法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">    .onEach &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">        println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;.onCompletion &#123;</span><br><span class="line">        println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为了让catch可以捕获<strong>所有异常</strong>，把catch放到collect之前，collect留空，业务代码写在onEach中。</li>
<li>onCompletion一定可以执行，上面的写法中，如果上游有异常，异常参数是会不为null，但是我们不要管它，留给catch来处理。这里的执行顺序是onCompletion再catch。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crash on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">            println(<span class="string">&quot;Got <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;.<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">            println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">        &#125;.onCompletion &#123;</span><br><span class="line">            println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调换位置。</p>
<p>第一个写法是catch可以捕获到onCompletion的异常，第二种不行。第二种先catch再onCompletion。</p>
<p>抽出一个拓展函数和用法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CoroutineScope(Dispatchers.Default).launch &#123;</span><br><span class="line">        flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            emit(<span class="number">1</span>)</span><br><span class="line">            emit(<span class="number">2</span>)</span><br><span class="line">            emit(<span class="number">3</span>)</span><br><span class="line">        &#125;.catchCompletionCollect(</span><br><span class="line">            action = &#123;</span><br><span class="line">                println(<span class="string">&quot;Got <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (it == <span class="number">2</span>) &#123;</span><br><span class="line">                    println(<span class="string">&quot;throw error&quot;</span>)</span><br><span class="line">                    <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            doWhenFlowCompleteSuccessful = &#123;</span><br><span class="line">                println(<span class="string">&quot;做一些完全成功才做的事&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            doWhenFlowMeetError = &#123;</span><br><span class="line">                println(<span class="string">&quot;meet error: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;做一些发生错误才做的事&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">99999</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">catchCompletionCollect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    doWhenFlowCompleteSuccessful: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    doWhenFlowMeetError: (<span class="type">Throwable</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.onEach &#123;</span><br><span class="line">            action(it)</span><br><span class="line">        &#125;</span><br><span class="line">        .onCompletion &#123; cause: Throwable? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (cause == <span class="literal">null</span>) &#123;</span><br><span class="line">                doWhenFlowCompleteSuccessful()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123;</span><br><span class="line">            doWhenFlowMeetError(it)</span><br><span class="line">        &#125;</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：<a href="https://medium.com/mobile-app-development-publication/kotlin-flow-imperative-or-declarative-exception-handler-bf8d64936366">medium</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
  </entry>
  <entry>
    <title>Android权限有感</title>
    <url>/2023/02/22/Android%E6%9D%83%E9%99%90%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>看了一晚的PermissionX系列文章，guolin写的挺好的。再次感慨Android系统的权限分类的请求的复杂。</p>
<p>在横向上，权限分为普通，危险，特殊三个级别。普通的只需要manifest中声明，危险则是运行时请求，特殊则是利用Intent导向一个特定界面来开启。</p>
<p>纵向上，随着Android版本的变化，要 <strong>做某一个功能</strong>，需要的权限 <strong>可能不一样</strong>；在高版本中，要用高版本的方法；在判断手机版本低时，要用旧方法。等等不言而喻。</p>
<p>干。</p>
]]></content>
      <categories>
        <category>编程感想</category>
      </categories>
  </entry>
  <entry>
    <title>Flow操作符——缓冲</title>
    <url>/2023/02/08/Flow%E6%93%8D%E4%BD%9C%E7%AC%A6%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h2 id="Buffer操作符"><a href="#Buffer操作符" class="headerlink" title="Buffer操作符"></a>Buffer操作符</h2><p>之前在旧博客用模拟餐厅上菜的例子讲过这个操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上菜——鸡肉</span><br><span class="line">运送鸡肉</span><br><span class="line">客人开始吃鸡肉</span><br><span class="line">客人吃完鸡肉</span><br><span class="line">上菜——鱼肉</span><br><span class="line">运送鱼肉</span><br><span class="line">客人开始吃鱼肉</span><br><span class="line">客人吃完鱼肉</span><br><span class="line">上菜——西瓜</span><br><span class="line">运送西瓜</span><br><span class="line">客人开始吃西瓜</span><br><span class="line">客人吃完西瓜</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>因为emit会挂起等collect执行完再resume，所以下一个菜要等客人吃完才上</strong>，那可不可以等客人一边吃就一边上菜呢？即要实现：collect不会令emit挂起，并保证emit的值按顺序到达，collect也对应的<strong>不取消（collectLatest就会取消）</strong>，也按顺序对应执行。</p>
<p><strong>用buffer可以解决</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.buffer().collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上菜——鸡肉</span><br><span class="line">运送鸡肉</span><br><span class="line">客人开始吃鸡肉</span><br><span class="line">上菜——鱼肉</span><br><span class="line">运送鱼肉</span><br><span class="line">上菜——西瓜</span><br><span class="line">运送西瓜</span><br><span class="line">客人吃完鸡肉</span><br><span class="line">客人开始吃鱼肉</span><br><span class="line">客人吃完鱼肉</span><br><span class="line">客人开始吃西瓜</span><br><span class="line">客人吃完西瓜</span><br></pre></td></tr></table></figure>

<p>由于有缓冲，上游和下游可以 <strong>并发</strong> 地执行。</p>
<h2 id="实现缓冲的另外一个方法"><a href="#实现缓冲的另外一个方法" class="headerlink" title="实现缓冲的另外一个方法"></a>实现缓冲的另外一个方法</h2><p>其实把 <code>buffer()</code> 改为 <code>flowOn(other Dispatcher)</code> （other Dispatcher指的是不同于 <code>collect</code> 所运行的上下文的调度器），也可以达到缓冲的效果。文档是这样说的：</p>
<blockquote>
<p>This operator retains a <em>sequential</em> nature of flow if changing the context does not call for changing the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">dispatcher</a>. </p>
<p>Otherwise, if <strong>changing dispatcher</strong> is required, it collects flow emissions <strong>in one coroutine</strong> that is run using a specified <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">context</a> and emits them from <strong>another coroutines</strong> with the original collector’s context using a channel with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/-factory/-b-u-f-f-e-r-e-d.html">default</a> <strong>buffer</strong> size between two coroutines similarly to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> operator, unless <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> operator is explicitly called before or after <code>flowOn</code>, which requests buffering behavior and specifies channel size.</p>
</blockquote>
<p>要就是说，要是 <code>flowOn()</code>中指定的调度器和收集的调度器不同，这样 <code>emit</code> 和 <code>collect</code> 就会运行在两个不同的协程中，然后有一个带有缓冲的channel把它们连接起来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.IO).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.Default).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking(Dispatchers.Default)&#123;</span><br><span class="line">    flow&lt;String&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;上菜——鸡肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鸡肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——鱼肉&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;鱼肉&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;上菜——西瓜&quot;</span>)</span><br><span class="line">        emit(<span class="string">&quot;西瓜&quot;</span>)</span><br><span class="line">    &#125;.onEach &#123;</span><br><span class="line">        println(<span class="string">&quot;运送<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(CoroutineName(<span class="string">&quot;没有改变调度器&quot;</span>)).collect &#123;</span><br><span class="line">        println(<span class="string">&quot;客人开始吃<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;客人吃完<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Buffer的参数"><a href="#Buffer的参数" class="headerlink" title="Buffer的参数"></a>Buffer的参数</h2><p>有两个参数，分别是 <strong>缓冲区大小</strong>和 <strong>溢出时的行为</strong>，都很简单，看注释即可。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a channel with an unlimited capacity buffer in the `Channel(...)` factory function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> UNLIMITED: <span class="built_in">Int</span> = <span class="built_in">Int</span>.MAX_VALUE   没有限制</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a rendezvous channel in the `Channel(...)` factory function &amp;mdash; a channel that does not have a buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> RENDEZVOUS: <span class="built_in">Int</span> = <span class="number">0</span>     没有缓冲，缓冲区为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a conflated channel in the `Channel(...)` factory function. This is a shortcut to creating</span></span><br><span class="line"><span class="comment"> * a channel with [`onBufferOverflow = DROP_OLDEST`][BufferOverflow.DROP_OLDEST].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> CONFLATED: <span class="built_in">Int</span> = -<span class="number">1</span>  缓冲区为<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Requests a buffered channel with the default buffer capacity in the `Channel(...)` factory function.</span></span><br><span class="line"><span class="comment"> * The default capacity for a channel that [suspends][BufferOverflow.SUSPEND] on overflow</span></span><br><span class="line"><span class="comment"> * is 64 and can be overridden by setting [DEFAULT_BUFFER_PROPERTY_NAME] on JVM.</span></span><br><span class="line"><span class="comment"> * For non-suspending channels, a buffer of capacity 1 is used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">val</span> BUFFERED: <span class="built_in">Int</span> = -<span class="number">2</span>  默认<span class="number">64</span></span><br></pre></td></tr></table></figure>

<p>也可以是自然数。</p>
<p><strong>要注意缓冲区为0不等于没有buffer修饰符的情况</strong>。当溢出策略为 suspend 的情况下，前者判断collect已消耗元素的标志是collect块开始处理，后者是collect块结束。<a href="https://stackoverflow.com/questions/65952256/kotlin-flow-buffer-capacity">一个buffer为0的案例</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
      <tags>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>StateFlow的equality判断</title>
    <url>/2023/03/04/StateFlow%E7%9A%84equality%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>StateFlow会对新的值和旧的值进行<strong>equality判断</strong>，如果返回true，就不会用这个new value去更新old value，就不会发送这个值。</p>
<p>这个equality判断会发生在 发送端 和 接收端。</p>
<h1 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h1><p>一般有两种发送方式，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">  <span class="keyword">val</span> mutableStateFlow = MutableStateFlow&lt;Person&gt;(Person())</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;用update的方式更改值（equal返回true）&quot;</span>)</span><br><span class="line">        mutableStateFlow.update &#123;<span class="comment">// 1 CAS校验 + 相等性判断，推荐使用</span></span><br><span class="line">            Person(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;用emit的方式更改值（equal返回true）&quot;</span>)</span><br><span class="line">        mutableStateFlow.emit(Person(<span class="string">&quot;&quot;</span>, <span class="number">0</span>))<span class="comment">// 2 只有相等性判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        mutableStateFlow.collect&#123;</span><br><span class="line"></span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">99999</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>update</code> 系列有 </p>
<ol>
<li>update</li>
<li>getAndUpdate</li>
<li>updateAndGet</li>
</ol>
<p>三种，区别只是 <strong>返回值</strong> 不同。</p>
<p><code>emit</code> 系列有</p>
<ol>
<li>emit</li>
<li>tryEmit</li>
</ol>
<p>都是继承自ShareFlow下来的。</p>
<p><strong>两个系列都是线程安全的</strong>，但线程安全不意味着不需要进行一些同步措施，这也是为什么推荐<code>update</code>系列。当要更新的值，依赖于旧值的参数的时候，比如新值的某一个字段是旧值的两倍，用<code>emit</code>系列就会产生同步问题。</p>
<p>比如说当emit在两个coroutine去跑，其中一个coroutine1拿到旧值之后，开始基于这个值去产生新值，但同时另外那个coroutine3也在基于这个旧值去产生新值。这样coroutine1发送的那个新值和coroutine2发送的新值就一样了。这不是想要的效果，所以 <code>update</code> 系列额外的<code>CAS</code>判断很重要。</p>
<p>源码的话大致如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateState</span><span class="params">(expectedState: <span class="type">Any</span>?, newState: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  </span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> oldState = _state.value</span><br><span class="line">        <span class="keyword">if</span> (expectedState != <span class="literal">null</span> &amp;&amp; oldState != expectedState) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 1 CAS support </span></span><br><span class="line">        <span class="keyword">if</span> (oldState == newState) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 2 Don&#x27;t do anything if value is not changing, but CAS -&gt; true</span></span><br><span class="line">        _state.value = newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>update</code> 系列会跑注释1和2，但<code>emit</code> 系列在运行到这个方法的时候 <code>expectedState</code> 总是为<code>null</code>，所以只会跑注释2</p>
<h1 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h1><p><code>collect</code>点进去也会有 <code>equality</code> 判断，不赘述。</p>
<h1 id="不要这个特性"><a href="#不要这个特性" class="headerlink" title="不要这个特性"></a>不要这个特性</h1><p>方法也很简单，使用 <code>ShareFlow</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> mutableStateFlow = MutableSharedFlow&lt;Person&gt;(</span><br><span class="line">        replay = <span class="number">1</span>,</span><br><span class="line">        extraBufferCapacity = <span class="number">0</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )<span class="comment">// buffer size = replay + extraBufferCapacity</span></span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;用emit的方式更改值（equal返回true）&quot;</span>)</span><br><span class="line">        mutableStateFlow.tryEmit(Person(<span class="string">&quot;&quot;</span>, <span class="number">0</span>))<span class="comment">// 不应该用emit</span></span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;用emit的方式更改值（equal返回true）&quot;</span>)</span><br><span class="line">        mutableStateFlow.tryEmit(Person(<span class="string">&quot;&quot;</span>, <span class="number">0</span>))<span class="comment">// 不应该用emit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        mutableStateFlow.collect&#123;</span><br><span class="line"></span><br><span class="line">            println(<span class="string">&quot;collect: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">99999</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 <code>ShareFlow</code> 这样配置，效果 <strong>基本</strong> 和 <code>StateFlow</code> 一样，要完全一样，还得</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MutableStateFlow(initialValue) is a shared flow with the following parameters:</span></span><br><span class="line"><span class="keyword">val</span> shared = MutableSharedFlow(</span><br><span class="line">    replay = <span class="number">1</span>,</span><br><span class="line">    extraBufferCapacity = <span class="number">0</span>,</span><br><span class="line">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">)</span><br><span class="line">shared.tryEmit(initialValue) <span class="comment">// emit the initial value</span></span><br><span class="line"><span class="keyword">val</span> state = shared.distinctUntilChanged() <span class="comment">// get StateFlow-like behavior, 这一步就相当于加上了 equality判断功能</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>based on <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">document</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
  </entry>
  <entry>
    <title>Stutz&#39;s tools</title>
    <url>/2023/02/12/Stutz&#39;s%20tools/</url>
    <content><![CDATA[<p>原文： <a href="https://movie.douban.com/review/14824656/">https://movie.douban.com/review/14824656/</a></p>
<p>乔纳·希尔在片尾重新声明了拍摄这部电影的原因：“我拍这部电影，因为想透过电影让更多人认识心理疗法，以及向大家推荐我在心理治疗中学到的工具；我拍这部电影，是因为我爱菲尔，是因为我爱这些工具让我拥有的生活。无论人们如何看待这部电影，对我来说重要的是我完成它了，我们一起，完成它了。”</p>
<p>第一个原因在片头出现过，后面的原因显然隐藏更深，也更私人化，影片的完成似乎也成为了希尔治愈自己的工具。说到治愈，想到了席安玛在某次《小妈妈》的采访中提到的一种说法。她希望《小妈妈》能够带给人们治愈，这同时也是电影和所有艺术作品的一个重要功能。</p>
<p>心理治疗是非常个人化的，也是一个漫长、复杂和相当需要专业性的过程，显然无法通过一部90分钟的纪录片完成。但希尔在片中用通俗易懂的方式介绍给了所有观众一些“工具”和理论，在此进行整理，也许可以帮助到有需要的朋友。</p>
<h3 id="1-激发自己的生命力（life-force）"><a href="#1-激发自己的生命力（life-force）" class="headerlink" title="1.激发自己的生命力（life force）"></a>1.激发自己的生命力（life force）</h3><p>如果你想要知道你该做什么，你是谁，你的人生使命，唯一的方法就是激发自己的生命力。唯有生命力，能在你迷失的时候引导你。你可以把它想象成一个三层的金字塔：最底层是你和你身体的关系；中间一层是你和其他人的关系；最上面是你和潜意识的关系。</p>
<p>和身体关系：你要做的就是让你的身体感觉更好，这通常是最有效的方式。具体包括三个方面：运动；饮食；睡眠。</p>
<p>和其他人的关系： 当一个人抑郁的时候，他会远离人际交往直到渐渐消失。而与其他人建立联系，会帮助你回到正常的生活。关键是你必须采取主动，不要别动等待。你可以邀请一个你不感情的人共进午餐，无所谓，一旦你这么做了，就会对你的状态产生积极的影响。</p>
<p>和潜意识的关系：你需要和你的潜意识建立联系。没有人知道自己的潜意识里有什么，除非你去激发它。有一个技巧是，你可以写下来，透过书写建立和自己潜意识的联系。不需要在意写下的是什么。如果你开始写作，写作就像一面镜子一样，会反映出你的潜意识里发生的事。如果你每天写，就会冒出很多你不知道自己在想的东西。</p>
<p>提升自己的生命力，你会发现你真正热爱的东西是什么。每个人都能做到以上这些。</p>
<p><img src="https://img2.doubanio.com/view/thing_review/l/public/p8226873.jpg"></p>
<h3 id="2-PART-X"><a href="#2-PART-X" class="headerlink" title="2.PART X"></a>2.PART X</h3><p>面对逆境时，你会直面part X。它是你身上充满批判性的一部分，非常反社会。它是一种无形的力量，想要阻止你改变或者成长，它想搞死你。它就像故事里的坏人，而“工具”则是战胜坏人的武器。 无论你想要做什么，Part X永远都在说：“不可能，放弃吧。”它会给你一份非常具体的报告，关于你是谁，你能做什么，它在你的身上制造一种原始的恐惧。</p>
<p>你永远无法完全摆脱Part X，你可以暂时打败它，但它会一直回来。因为只要身而为人，就永远无法逃离三个现实：痛苦、不确定性和永无止境的工作。  </p>
<p><img src="https://img9.doubanio.com/view/thing_review/l/public/p8226914.jpg" alt="图2:永远无法逃离的三个现实困境"><br>从另一方面说，我们需要Part X，否则我们就无法实现个人的成长。真正让你快乐的是战胜它的过程，你必须学会爱上处理以上三个现实困境的过程。人类创造力的最高表现，就是在逆境中开创新局。</p>
<h3 id="3-珍珠串（string-of-pearls）"><a href="#3-珍珠串（string-of-pearls）" class="headerlink" title="3.珍珠串（string of pearls）"></a>3.珍珠串（string of pearls）</h3><p> 你只需要画一串珍珠，画一条线，然后一个圈，再来一条线，再来一个圈。每个圈都等于一个行动，每个行动的价值都是平等的，我只用自己采取的行动来检视自己。无论失败还是成功，你都要继续往前。例如每天起床也是一个珍珠，起床后做的事情也是一个珍珠。不要赋予每个行动不同的价值。 真正的自信是活在不确定性中，永远继续前进。赢家不是那些总是做出最佳决定或者看起来最风光的人，而是愿意承担风险，秉持某种信念，并勇于承担结果的人。如果结果是不好的，也没有关系，继续前进，能做到这样是最好的。</p>
<p>在每个珍珠里，都有一个小黑点，这个黑点就是一颗粑粑。这就好像你所做的所有努力，最终结果都一定不是完美的，里面一定会有一颗粑粑。你并不要担心这颗粑粑是好的还是不好的，你只需要继续前进，把下一颗珍珠串到线上。</p>
<p><img src="https://img9.doubanio.com/view/thing_review/l/public/p8226986.jpg" alt="图3:珍珠串和粑粑"></p>
<h3 id="4-影子（the-shadow）"><a href="#4-影子（the-shadow）" class="headerlink" title="4.影子（the shadow）"></a>4.影子（the shadow）</h3><p>每个人都有影子，它就是人们感到羞耻的部分。你要做的第一件事情就是找到自己的影子，你必须将它影像化，看到它，才能专注于解决它。</p>
<p>-闭上眼睛，想象你人生中的某个时刻，你感到自卑、尴尬、沮丧、被拒绝、羞耻，你不要想承认这部分的自己，但你永远无法摆脱它。</p>
<p>-跟你的影子对话。问它对你以前处理它的方式有什么感觉？影子需要关注，它需要的不是外部的关注，而是你的关注。</p>
<p>-问它你需要如何弥补长久以来你对它缺乏关注的事实。</p>
<p>-睁开眼睛。</p>
<p>与影子对话是一个非常有效的工具，特别是在压力很大的时候。我们的目标是使用这个工具包容任何有可能出现的结果。如果我们能满意最真实的自己，其他人的看法将只会对我们产生非常小的影响。重点不是影子好不好看，重点是你需要持续和它产生连接。如果你不关注它，它会让你做出具有破坏性的事情。所以它既是一个工具，让你在当下感觉好受一些，也是一种哲学，告诉你自己将何去何从。与影子同步代表了一种完整，意味着我不需要其他东西就可以感受到一个完整的自我，这是一种非常自由的感受。</p>
<h3 id="5-快照（the-snapshot）"><a href="#5-快照（the-snapshot）" class="headerlink" title="5.快照（the snapshot）"></a>5.快照（the snapshot）</h3><p>快照也叫幻境，它也是part X的一部分。快照意味着你在寻找一次完美的体验，可能是一个完美的妻子，完美的存款数字，完美的电影等。它是什么并不重要，因为它实际上并不存在。它只是你脑海中的一个想象。</p>
<p>快照的本质什么？它是静止的，不会动，平面的，没有焦距。当你拍下这样的一张照片后，你会对着它幻想：如果我能进入这个完美的世界该多好，神奇的事情就会发生。但你不要忘了，永远有三样东西存在于我们的现实世界中：痛苦、不确定性和永无止境的工作。</p>
<p><img src="https://img1.doubanio.com/view/thing_review/l/public/p8232930.jpg" alt="图4:快照与现实"></p>
<h3 id="6-迷宫（the-Maze）"><a href="#6-迷宫（the-Maze）" class="headerlink" title="6.迷宫（the Maze）"></a>6.迷宫（the Maze）</h3><p>迷宫总是和其他人有关，它也是part X的一部分。它的产生来源于part X想要“公平”。最为典型的例子是，当你谈论另一个人时，你告诉自己：“只要他们做出弥补，我就会原谅他们。无论是他们对我生气，劈腿或是其他事情。”你感觉自己被亏待，而你对公平的追求让你的生活停摆了。</p>
<p>人生苦短，时间飞逝，你可能没有意识到，我们并没有时间浪费在这些破事儿上。大部分人，他们都希望得到补偿，他们希望所有的一切都是公平的，一切都是均衡的，但你往往无法从别人身上获得这些。你唯一能做的，是自己给予自己满足感，自己找回平衡。我们可以借助“主动的爱”这一工具走出迷宫。</p>
<p><img src="https://img2.doubanio.com/view/thing_review/l/public/p8232971.jpg" alt="图5:迷宫"></p>
<h3 id="7-主动的爱（active-love）"><a href="#7-主动的爱（active-love）" class="headerlink" title="7.主动的爱（active love）"></a>7.主动的爱（active love）</h3><p>-闭上眼睛，想象你被一个完全由爱组成的宇宙包围，我知道这听起来很疯狂，但试试吧。不要预设立场，我们一起看看会发生什么。</p>
<p>-我试着定义这个世界：这是一个几乎完全由爱的能量构成的世界，感觉自己吸收到了全宇宙的爱。现在，轻轻地，但稳稳地将所有的爱放进你心里。就在那一刻，你主导了全宇宙的爱。</p>
<p>-你现在要做的是，看到那个让你生气的人，那个你讨厌、你鄙视的人。你把你心中积聚的所有的爱传递给他。你毫无保留，你付出一切。你感觉到并且看到你的爱进入了对方的身体，这非常重要。从这一时刻开始，你们成为了一体。你感觉到：“如果我能和这个混蛋成为一体，那我可以和任何人成为一体。”这是一种无畏的感觉，几乎是征服感。</p>
<p>人们会说，你是在叫我去爱一个我讨厌的人。我想说，这并不是去原谅谁，这不是为了别人，这是为了让你感到完整，并且从迷宫中解脱出来。你想做一些正确的事情吗？你想创造一些什么吗？人生就是不断前进，如果你想浪费时间去玩迷宫游戏当然可以，但你会永远失去那些时间。</p>
<h3 id="8-感恩的心流（the-Greatful-Flow-）"><a href="#8-感恩的心流（the-Greatful-Flow-）" class="headerlink" title="8.感恩的心流（the Greatful Flow ）"></a>8.感恩的心流（the Greatful Flow ）</h3><p>你的每个想法都会影响你的心情，你的想法不是正面的就是负面的。感恩的心流想要选择正面的想法，而part X想要你有负面的心流，因此会形成乌云。有了乌云的存在，你会看不到太阳，以至于你忘记了太阳其实一直都在那里。问题是，你要如何穿过乌云？答案是：心怀感激。</p>
<p>感恩的心流会带给你一种流动感，让你觉得总有一些正面的东西存在，就算在当下你看不到它们。感恩的心流并不是某个你具体想感激的东西，它是创造这些东西的过程。</p>
<p>-闭上眼睛， 说出最多四个你要想感激的东西。这些东西越小越好，越小越容易让你聚焦。你要慢慢地去做这件事情，你要是去感受感恩。</p>
<p>-继续去想象你想感激的东西但不要说出来，继续创造感恩的心流。</p>
<p>-接下来，你会觉得自己要创造另一个感恩的想法，但你没有。你阻挡它，你只感觉到那股产生感恩想法的力量。当它变得越来越强烈，你会觉得自己被它占领。那就是感恩的心流。</p>
<p>重点不是一再重复说出你感激的东西，而是要把它变成一个创造性的行为。当你必须去发掘并且努力找到这些东西时，这个过程本身就会改变你的情绪。</p>
<p>使用这个工具的最佳时机是你的想法失去控制时。最糟糕的做法是跟它们争辩，那一点帮助也没有，只会造成更加可怕的后果。感恩并不仅是“我很开心，有人能够帮助我”，而是一种状态，一种你尽可能想要置身其中的状态。因为这个状态能连结你，帮助你穿过乌云，看到阳光。part X会说你不应该感恩，你是一个受害者，你得到的远远不够。这就是魔鬼的发言，这是非常典型的part X。</p>
<h3 id="9-丧失处理（loss-processing）"><a href="#9-丧失处理（loss-processing）" class="headerlink" title="9.丧失处理（loss processing）"></a>9.丧失处理（loss processing）</h3><p> 它是一个帮助你处理失去的工具，大部分人在处理这个主题时都表现得很差。他们表现得很差，不单是在失去的时候变得抑郁或者失落，而是在失去之前，他们就会担心失去。</p>
<p>这个工具的目标是获得不执着的力量，意味着我可以去追求某些东西，得不得到的话也没关系，我依然想要追求它，但我也愿意承担失去。</p>
<p>-首先，挑选一个你觉得自己过度执着的东西。 可能是一个人，一份工作，一个小东西，都无所谓。但必须是一个你不愿意放手的东西。你担心你一旦放手，糟糕的事情就会发生。</p>
<p>-现在，想象你抓着这个东西，如果它不是实在的物体也没有关系，只需要想象你抓着它，就像抓着一根树枝一样。你觉得很害怕，你不敢放手，但你还是放手了。</p>
<p>-你一旦放手，就开始坠落。这不是什么糟糕的感觉，出乎你的意料，坠落其实是一个缓慢而且温和的过程。在坠落的过程中，你对自己说：“我愿意失去一切。”你需要把这句话默默说出来，并思考它背后的意义。</p>
<p>-当你默默说出这句话时，你撞到了身下的太阳表面，你的身体开始燃烧。在那一刻，你失去了所有。因为你得有肉体才能拥有一切。要是你的肉体燃烧殆尽，你就只是其中的一个光束。你向四面八方辐射，你辐射出的都是充满爱、流动的能量。</p>
<p>-然后你环顾四周，你看到周围无数的太阳，就像你所在的那个，它们都在向外辐射。然后你听到所有的太阳都在说：我们无处不在。这个世界叫做太阳世界。</p>
<p>-你能做的就是付出，你不能索取，你不能抓住任何东西。现在，你可以睁开眼睛了。</p>
<p>另一种思维方式：你没有要变得不执着，你只是试着在每次害怕失去的时候试着不要执着。对大部分人来说，他们这辈子从来没有体验过不执着的感受。就算他能朝这个方向前进，也是有帮助的。 所以目标并不是完全变得不执着，而是努力不让失去一个人、地、物的经历完全夺走你的生活，以及你的完整感。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>行为建议</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread的UncaughtExceptionHandler</title>
    <url>/2023/02/06/Thread%E7%9A%84UncaughtExceptionHandler/</url>
    <content><![CDATA[<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mainFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> t = thread(start = <span class="literal">false</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;!!!!!&quot;</span>)</span><br><span class="line">        &#125;.apply &#123;</span><br><span class="line">            setUncaughtExceptionHandler &#123; thread, throwable -&gt;</span><br><span class="line">                println(<span class="string">&quot;child&quot;</span> + throwable.message)</span><br><span class="line">            &#125;</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Main&quot;</span> + e.message)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainFunction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">child!!!!!</span><br></pre></td></tr></table></figure>



<p>try catch不能捕获在trycatch括号内开的子线程抛出的异常，可以为线程设置一个 <code>UncaughtExceptionHandler</code>。</p>
<p>我联想到Coroutine中，try catch同样无法捕获括号内新开的<strong>子协程</strong>内抛出的错误，与之不同的是，协程的错误不是定义子协程的exception handler来处理，而是可以为TopLevelScope或Top level coroutine定义异常处理器。</p>
<p>参考资料：</p>
<p><a href="https://github.com/JeckOnly/passage/blob/master/Android/Kotin%20%E5%8D%8F%E7%A8%8B.md#1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">以前写的协程异常处理</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1652118">Java多线程捕获</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewModel_cheatsheet</title>
    <url>/2023/02/27/ViewModel-cheatsheet/</url>
    <content><![CDATA[<p><img src="https://developer.android.com/static/images/topic/libraries/architecture/viewmodel-apis-cheatsheet.png"></p>
<p>保存一下链接</p>
<p><a href="https://developer.android.com/static/images/topic/libraries/architecture/viewmodel-apis-cheatsheet.png">cheat sheet</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>架构</category>
        <category>架构组件</category>
      </categories>
  </entry>
  <entry>
    <title>channelFlow的并发emit</title>
    <url>/2023/03/02/channelFlow%E7%9A%84%E5%B9%B6%E5%8F%91emit/</url>
    <content><![CDATA[<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    channelFlow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            send(<span class="number">1</span>)<span class="comment">// send而不是flow</span></span><br><span class="line">        &#125;</span><br><span class="line">        withContext(Dispatchers.Default) &#123;</span><br><span class="line">            send(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>channelFlow</code>可以在不同的上下文中发射值。</p>
<p>用 <code>flow&#123;&#125;</code> 构建器则不行，代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        withContext(CoroutineName(<span class="string">&quot;withContext&quot;</span>)) &#123;</span><br><span class="line">            emit(<span class="number">1</span>)<span class="comment">// 在另外的上下文发射值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">报错：Flow invariant <span class="keyword">is</span> violated</span><br></pre></td></tr></table></figure>



<h3 id="channelFlow"><a href="#channelFlow" class="headerlink" title="channelFlow"></a>channelFlow</h3><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>创建一个冷流，它允许element在不同的上下文中并发地产生. </p>
<p>The resulting flow completes as soon as <strong>the code in the block and all its children completes</strong>. Use <code>awaitClose</code> as the last statement to keep it running. </p>
<p>背压措施：A channel with the <strong>default buffer size</strong> is used. Use the buffer operator on the resulting flow to specify a user-defined value and to control what happens when data is produced faster than consumed, i.e. to control the back-pressure behavior.</p>
<h4 id="awaitClose"><a href="#awaitClose" class="headerlink" title="awaitClose"></a>awaitClose</h4><p>显式地，不让<code>channelFlow</code>的<code>block</code>块结束。示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example1 当the code in the block and all its children completes，channelFlowblock块退出</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    channelFlow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// block</span></span><br><span class="line">        launch(Dispatchers.Default) &#123;</span><br><span class="line">            send(<span class="number">99</span>)</span><br><span class="line">            delay(<span class="number">3000</span>)</span><br><span class="line">            send(<span class="number">99</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            repeat(<span class="number">5</span>) &#123;</span><br><span class="line">                send(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example2 保持channelFlow的block块作用域运行，除非被close或cancel</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    channelFlow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        launch(Dispatchers.Default) &#123;</span><br><span class="line">            send(<span class="number">99</span>)</span><br><span class="line">            delay(<span class="number">3000</span>)</span><br><span class="line">            send(<span class="number">99</span>)</span><br><span class="line">            close() <span class="comment">// this@channelFlow.cancel()</span></span><br><span class="line">        &#125;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            repeat(<span class="number">5</span>) &#123;</span><br><span class="line">                send(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        awaitClose &#123;</span><br><span class="line">            println(<span class="string">&quot;produce scope 结束&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为什么flow内不能切换上下文"><a href="#为什么flow内不能切换上下文" class="headerlink" title="为什么flow内不能切换上下文"></a>为什么flow内不能切换上下文</h3><p>并不是不能切换上下文，只是<code>emit</code>不能在另外的上下文，下面这样的代码还是可以的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = async(Dispatchers.IO) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>)<span class="comment">// 一些CPU计算</span></span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">        emit(result.await())</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    &#125;.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那本文开头的代码为什么不行，<a href="https://elizarov.medium.com/execution-context-of-kotlin-flows-b8c151c9309b">据这篇文章所说</a>，是因为如果那样做，<code>collect</code>的代码块可能在错误的上下文去运行，然后需要写一些样板代码去确保 <code>collect</code> 的代码能在正确的上下文去运行。没太看懂老实说。</p>
<p>最后建议使用 <code>flowOn</code> 操作符去进行上游的上下文的切换。</p>
<h3 id="callbackFlow"><a href="#callbackFlow" class="headerlink" title="callbackFlow"></a>callbackFlow</h3><p><code>callbackFlow</code> 除了强制使用<code>awaitClose</code>之外，并没有和channelFlow什么不同。<code>callbackFlow</code>的设计是为了桥接一些旧的API，那些api设计成传callback.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">flowFrom</span><span class="params">(api: <span class="type">CallbackBasedApi</span>)</span></span>: Flow&lt;T&gt; = callbackFlow &#123;</span><br><span class="line">    <span class="keyword">val</span> callback = <span class="keyword">object</span> : Callback &#123; <span class="comment">// Implementation of some callback interface</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNextValue</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// To avoid blocking you can configure channel capacity using</span></span><br><span class="line">            <span class="comment">// either buffer(Channel.CONFLATED) or buffer(Channel.UNLIMITED) to avoid overfill</span></span><br><span class="line">            trySendBlocking(value)</span><br><span class="line">                .onFailure &#123; throwable -&gt;</span><br><span class="line">                    <span class="comment">// Downstream has been cancelled or failed, can log here</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onApiError</span><span class="params">(cause: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            cancel(CancellationException(<span class="string">&quot;API Error&quot;</span>, cause))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompleted</span><span class="params">()</span></span> = channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">    api.register(callback)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Suspends until either &#x27;onCompleted&#x27;/&#x27;onApiError&#x27; from the callback is invoked</span></span><br><span class="line"><span class="comment">     * or flow collector is cancelled (e.g. by &#x27;take(1)&#x27; or because a collector&#x27;s coroutine was cancelled).</span></span><br><span class="line"><span class="comment">     * In both cases, callback will be properly unregistered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     awaitClose &#123; api.unregister(callback) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>强制使用 <code>awaitClose</code> 是为了让你使用callback api的时候减少bug的发生机会，因为你必须在 <code>awaitClose</code>  处做点什么，这样可以提醒自己。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
        <category>Flow</category>
      </categories>
  </entry>
  <entry>
    <title>coroutineScope vs supervisorScope</title>
    <url>/2023/02/20/coroutineScope%20vs%20supervisorScope/</url>
    <content><![CDATA[<p>总结并不完全，只列出一些主要异同。</p>
<h3 id="同"><a href="#同" class="headerlink" title="同"></a>同</h3><h4 id="1-内部子协程及作用域本身都完成了函数才完成"><a href="#1-内部子协程及作用域本身都完成了函数才完成" class="headerlink" title="1 内部子协程及作用域本身都完成了函数才完成"></a>1 内部子协程及作用域本身都完成了函数才完成</h4><blockquote>
<p>This function returns as soon as the given block and all its child coroutines are completed.</p>
</blockquote>
<h4 id="2-都不参与函数调用处所在的scope的结构化并发"><a href="#2-都不参与函数调用处所在的scope的结构化并发" class="headerlink" title="2 都不参与函数调用处所在的scope的结构化并发"></a>2 都不参与函数调用处所在的scope的结构化并发</h4><p>在函数调用处 re-throw exception。</p>
<h3 id="异"><a href="#异" class="headerlink" title="异"></a>异</h3><p>主要体现在异常情况下的 parent-child 取消逻辑。</p>
<h4 id="coroutineScope是双向的取消"><a href="#coroutineScope是双向的取消" class="headerlink" title="coroutineScope是双向的取消"></a>coroutineScope是双向的取消</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>子协程发生异常 -&gt; coroutineScope作用域整个取消 -&gt; 其他子协程也被取消</p>
<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>coroutineScope取消&#x2F;作用域本身异常 -&gt; 取消内部所有子协程</p>
<h4 id="supervisorScope是单向的取消"><a href="#supervisorScope是单向的取消" class="headerlink" title="supervisorScope是单向的取消"></a>supervisorScope是单向的取消</h4><h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><p>supervisorScope取消&#x2F;作用域本身异常 -&gt; 取消内部所有子协程。</p>
<p>但是内部的子协程异常不会导致supervisorScope作用域的取消。需要像顶层协程那样给子协程设置Handler为他们设置独立的错误处理器，不设置的话没有处理就会打印异常信息。</p>
<p>可以从博客中另外一篇《协程异常处理总结》了解更多。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode_50_螺旋矩阵</title>
    <url>/2023/02/09/leetcode-50-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>这道题看到很多解法都是边界法。然后看到另外一种有意思的解法。</p>
<p>用一个队列，储存四种 <strong>行为</strong>，即 event，这个行为不合法之后，循环下一个行为，直到行为的开始也不合法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ListNode <span class="keyword">import</span> ListNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 50</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        toDoList = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        result = []</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        errorNum = <span class="number">101</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        result.append(matrix[x][y]) <span class="comment"># 要先处理第一个数啦</span></span><br><span class="line">        matrix[x][y] = errorNum</span><br><span class="line">        temp = toDoList.pop(<span class="number">0</span>)</span><br><span class="line">        toDoList.append(temp)</span><br><span class="line">        toDoX = temp[<span class="number">0</span>]</span><br><span class="line">        toDOY = temp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ((x + toDoX &lt; m) <span class="keyword">and</span> (y + toDOY &lt; n) <span class="keyword">and</span> (matrix[x + toDoX][y + toDOY] != errorNum)):</span><br><span class="line">                temp = toDoList.pop(<span class="number">0</span>)</span><br><span class="line">                toDoList.append(temp)</span><br><span class="line">                toDoX = temp[<span class="number">0</span>]</span><br><span class="line">                toDOY = temp[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((x + toDoX &lt; m) <span class="keyword">and</span> (y + toDOY &lt; n) <span class="keyword">and</span> (matrix[x + toDoX][y + toDOY] != errorNum)):</span><br><span class="line">                    <span class="comment"># 新的开始都不合法了说明该结束了</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 下一个值合法</span></span><br><span class="line">                x += toDoX</span><br><span class="line">                y += toDOY</span><br><span class="line">                result.append(matrix[x][y])</span><br><span class="line">                matrix[x][y] = errorNum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    matric = [[<span class="number">1</span>]]</span><br><span class="line">    <span class="built_in">print</span>(solution.spiralOrder(matric))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>select优先选择第一个可用的clause</title>
    <url>/2023/03/03/select%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%94%A8%E7%9A%84clause/</url>
    <content><![CDATA[<p>when more than one clause are ready, select will choose the first one. Pls take a look at the code below:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectAorB</span><span class="params">(a: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, b: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span>: String =</span><br><span class="line">    select&lt;String&gt; &#123;</span><br><span class="line">        a.onReceiveCatching &#123; it -&gt;</span><br><span class="line">            <span class="keyword">val</span> value = it.getOrNull()</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="string">&quot;a -&gt; &#x27;<span class="variable">$value</span>&#x27;&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="string">&quot;Channel &#x27;a&#x27; is closed&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b.onReceiveCatching &#123; it -&gt;</span><br><span class="line">            <span class="keyword">val</span> value = it.getOrNull()</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="string">&quot;b -&gt; &#x27;<span class="variable">$value</span>&#x27;&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="string">&quot;Channel &#x27;b&#x27; is closed&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> a = produce&lt;String&gt; &#123;</span><br><span class="line">        repeat(<span class="number">4</span>) &#123; send(<span class="string">&quot;Hello <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = produce&lt;String&gt; &#123;</span><br><span class="line">        repeat(<span class="number">4</span>) &#123; send(<span class="string">&quot;World <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">10</span>) &#123; <span class="comment">// 打印最早的八个结果</span></span><br><span class="line">        println(selectAorB(a, b))</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The output result is </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">a -&gt; <span class="string">&#x27;Hello 0&#x27;</span></span><br><span class="line">a -&gt; <span class="string">&#x27;Hello 1&#x27;</span></span><br><span class="line">b -&gt; <span class="string">&#x27;World 0&#x27;</span></span><br><span class="line">a -&gt; <span class="string">&#x27;Hello 2&#x27;</span></span><br><span class="line">a -&gt; <span class="string">&#x27;Hello 3&#x27;</span></span><br><span class="line">b -&gt; <span class="string">&#x27;World 1&#x27;</span></span><br><span class="line">Channel <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> closed</span><br><span class="line">Channel <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> closed</span><br><span class="line">Channel <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> closed</span><br><span class="line">Channel <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> closed</span><br></pre></td></tr></table></figure>

<p>Why the result is “aabaab” and all the last is “Channel ‘a’ is closed” that will be return by <code>onReceive</code>  called on channel a when it is closed?</p>
<p>OK, first, why all the last is “Channel ‘a’ is closed” is because select will always choose the first clause that is ready to use. In this case, after “a -&gt; ‘Hello 0’” is printed 4 times, channel a had been closed. So the <code>onReceiveCatching</code> invoked on channel a will always return immediatly. It won’t be suspended anymore.</p>
<p>Second, why there is two “a” followed by 1 “b”?</p>
<p>Based on this <a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111#issuecomment-327716427">issue</a>, I try to answer this question. There is three coroutine instance in the program, one main coroutine and the two last coroutine to run channel.</p>
<p>因为是运行了main，然后是先后创建 a, b channel。所以一开始的coroutine 队列是序号1所示。</p>
<p><img src="https://i.pinimg.com/564x/87/be/14/87be144c68d4163c77e9d281548e045f.jpg"></p>
<p>然后main在执行select的过程中没有收到值，所以就挂起了。这时候队列如序号2</p>
<p>然后a channel发送了一个值，main的状态变为receive a，a发送的值可以看作被 <strong>接收</strong> 了，所以a可以再执行一次send，因为这两个都是<strong>capacity为0的rendezvous channel</strong>, 所以这次a就挂起了，这时候a的状态为准备发送的状态。这时候队列如序号3</p>
<p>然后b准备发送值，但不得不挂起，因为没有接收啊，所以b进入准备发送的状态。这时候队列如序号5.</p>
<p>main coroutine 终于 resume了，然后它先打印 a给它的，然后又看了看，现在有两个 a, b 都准备发送。<strong>根据select 的优先级</strong>， 它选了a先，然后再b，所以就打印”aab“了。然后这时候队列如序号6.进入下一个循环。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
  </entry>
  <entry>
    <title>“穿山甲：被捕杀最多的动物”观看有感</title>
    <url>/2023/02/14/%E2%80%9C%E7%A9%BF%E5%B1%B1%E7%94%B2%EF%BC%9A%E8%A2%AB%E6%8D%95%E6%9D%80%E6%9C%80%E5%A4%9A%E7%9A%84%E5%8A%A8%E7%89%A9%E2%80%9D%E8%A7%82%E7%9C%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>这部记录片挺无聊的，一个女人，变卖家产，投身到非洲穿山甲的保护之中。成果在片中一点没说，就说时势很艰难，资金人力啥的都不够，中间记录的一大段都是女主在非洲的一个房子里和她养的一只穿山甲的日常，后面就说了她去亚洲越难和中国拜访，理由是因为亚洲对穿山甲鳞片的药用间接导致非洲穿山甲被大量捕杀所以要去看看。但逛了一圈似乎也只是了解了一些显而易见的事实fact。比如时势不容乐观，要抓紧时间行动。然后片尾就说为了让更多人了解穿山甲所以有一个摄影师来拍女主养的那只宠物的日常来发到网上。</p>
<p>女主似乎说的很伟大，变卖家产无私地投入到保护这种动物之中，然后片中关于她的成果是微不足道的——养了一只可爱的穿山甲在家里。</p>
<p>从数据上来说每年都有很多动物灭绝，为啥那么多人投入那么多人力物力去保护那几个物种。可能因为穿山甲比较可爱？老虎很威猛？比其他那些丑不拉几的频危动物更值得保护？</p>
<p>既然选择保护这种而不保护那种，这就不是一种无私，这绝对带有私心。而目的是什么，对动保工作者本身能带来什么，只有他们知道。</p>
<blockquote>
<p>一个知乎回答很可爱：听说印第安人因为美洲没有马，所以没有发展出轮子，导致科技树受到影响，谁知道要灭绝的生物是不是下一匹马呢</p>
</blockquote>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>《东邪西毒》</title>
    <url>/2023/02/23/%E3%80%8A%E4%B8%9C%E9%82%AA%E8%A5%BF%E6%AF%92%E3%80%8B/</url>
    <content><![CDATA[<p>欧阳锋从小是孤儿，和他哥哥一起生活。他从小就学会了如何保护自己。若要使自己不受伤害，他在一开始就拒绝。他爱着一个女人，但就像一个自卑的小孩，不敢说出口，他怕被拒绝会受伤。其实那个女人也喜欢他，但她年轻气盛，她和他赌气，就是要欧阳锋亲口说出”我喜欢你“才和他结婚。在要嫁给他哥哥的那个晚上，欧阳锋想要带她走，她却死活不跟他走。</p>
<p>后来，和黄药师对话时说：”我只希望他说一句话，他都不肯说，他太自信了，以为我一定会嫁给他，谁知道我嫁给了他哥哥。在我们结婚那天，他要我跟他走，我没答应。为什么要到失去的时候才去争取？既然是这样，我不会让他得到。“</p>
<p>最后，欧阳锋只身一人离开白驼山，在沙漠中做起了杀手中介；她悔恨着失去的美好年华没和他在一起。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>《伊尼舍林的报丧女妖》有感</title>
    <url>/2023/02/16/%E3%80%8A%E4%BC%8A%E5%B0%BC%E8%88%8D%E6%9E%97%E7%9A%84%E6%8A%A5%E4%B8%A7%E5%A5%B3%E5%A6%96%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>并不是一部恐怖片。报丧女妖是爱尔兰神话中传说在某人将要死去的时候便会开始哭号的神灵&#x2F;妖怪。</p>
<p>若某一天，一个非常平常普通的一天，你的好朋友，突然不理你了，宣布不会再和你说话，如果你强迫他，试着去接近他，他就切下一根手指，你会有什么反应？我想都会和Padraic那般惊慌失措。、</p>
<p>Colm在年纪已经不小的一个时刻突然醒悟不能继续浪费生命，他认为继续和Padraic做朋友、继续那些每天毫无意义的闲聊只是在浪费时间。他喜欢音乐，会拉提琴，崇拜莫扎特，想留下些什么在这个世界上——他希望有更多人认识他，在他死后会被人记住。</p>
<p>而和他做了好几十年老朋友的“老实人”Padraic则是一个安分守己、教育程度比较低的nice man。也就是脾气很好，也会说笑，非常活在当下，在白天照顾几头牛羊晚上则去酒吧喝酒就感到一天十分满足的普通人。其实岛上的都是普通人吧，只不过Colm在某一天有了存在主义危机，觉得不能这么庸俗下去。</p>
<p>Colm突然单方面宣布终结和Padraic的老朋友关系，Padraic自然是迷惑不解。Padraic的生活破碎了。他脑子比较简单，不理解Colm想过一种“更有意义”的生活。Colm说和他的闲聊一点意义都没有，只是在浪费生命，可几十年不都是这么过来的吗。</p>
<p>后来就是互相伤害的故事了。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>《擅长捉弄的高木同学剧场版》有感</title>
    <url>/2023/02/16/%E3%80%8A%E6%93%85%E9%95%BF%E6%8D%89%E5%BC%84%E7%9A%84%E9%AB%98%E6%9C%A8%E5%90%8C%E5%AD%A6%E5%89%A7%E5%9C%BA%E7%89%88%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>TV动画的核心——羞涩、捉弄等元素在剧场版中占的比重实在可怜。中间养猫那场戏过了之后，不知道为啥西片就A了上去。连表白都还没有就直接来了一句——“我会让你幸福”。大哥你之前可是被盯着看都会脸红得像番茄的啊。</p>
<p>强行结局而结局。带有太多的日式哀伤。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>《春光乍泄》有感</title>
    <url>/2023/02/28/%E3%80%8A%E6%98%A5%E5%85%89%E4%B9%8D%E6%B3%84%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>《春光乍泄》的英文名叫《Happy together》,但昨晚看完之后，happy的场景其实是不多的。影片一开始就是两个人在去瀑布的路上迷路，然后争吵分手了。后来何宝荣被打伤，回来找黎耀辉，两个人在一间小房子里度过了一段时光。但何宝荣终究是不安分的人，两个人再次分开。最后黎耀辉回到香港，何宝荣回到当时两个人呆过的小房子，搂着萦绕着黎的气息的被子痛哭。</p>
<p>我一开始就觉得它们两个人不搭，所以对后面何离开黎，以及它们最后没有在一起没有什么惊讶。</p>
<p>觉得它们不可能在一起是因为我看出来它们性格不相容。在去找瀑布的路上，车子坏了。</p>
<p>黎呛何说：“又说会看地图，走错路了！”</p>
<p>何本来躺在后座：“走错路用不着死吧？走错路不就掉头。”</p>
<p>车子发动不起来。</p>
<p>黎：“操！买什么汽车，搭巴士不好好的吗！这废铁还打不着火！你来开吧！”</p>
<p>何：“有废铁好过没有，我们现在很有钱吗？有车可以坐好过挤巴士吧！三十多个小时！”</p>
<p>黎：“旅行就是这样的啦！”</p>
<p>何：“我可没想过是这样子”</p>
<p>他们是两个性格的人，黎喜欢有计划，有方向的去做事情，而何倾向于顺其自然，随心地自由自在地；黎比较传统，辛苦一点也没什么。而何不太能吃苦，喜欢更舒服的style。从后面两个人分手后，何去和其他外国男同们整体泡酒吧，纸醉金迷，黎却想着攒钱回香港去酒吧打工，也可以看的出来。对于后面两个人的吵架，我基本都是“迟早的事”的态度。后面何的伤快好了之后，穿的酷酷的出去买烟，回家后被黎怀疑，“去哪里？” “买烟” “买烟要穿的这么好看？” “那么久没出过门了穿好看一点出门不行吗？”，其实黎耀辉并不是没有控制欲的，有控制欲说明有爱。他很爱何宝荣。</p>
<p>怎么说的，不合适有什么办法，也就是留一段共同记忆在生命长河里。生活还是要向前看。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>《贪婪的多巴胺》有感</title>
    <url>/2023/02/19/%E3%80%8A%E8%B4%AA%E5%A9%AA%E7%9A%84%E5%A4%9A%E5%B7%B4%E8%83%BA%E3%80%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>看过一个故事说一个年轻人为寻求幸福人生的秘诀去寻求一位智者，智者让他端着杯水在不洒出来的前提下游览一栋豪华的房子，里面摆着很多美丽的名画等吸引人心的事物。最终年轻人在热切地观赏房子中各种美丽的东西的时候杯子里的水所剩无几，在小心翼翼地保证杯子里的水不洒出来的时候几乎没看到房子里摆了什么。智者说幸福的秘诀就是平衡。</p>
<p>《贪婪的多巴胺》的最后也聚焦到——幸福的秘诀就是平衡——这一主题。平衡当下与未来，平衡享受当下与欲望未来，平衡满足于现状的内心安宁与冒险开拓追求更多的野心欲望，平衡大脑的当下回路与欲望回路，平衡当下分子和多巴胺。</p>
<p>这本书覆盖的面挺广，工作，家庭，生活都有涉及，但遗憾的是稍显浅薄不够深入。大脑原理也有一定深入，但“为什么”讲的比较多，如何去做、如何去改善等方法论没怎么提及。</p>
<p>另一本《Dopamine Nation》方法论可能比较深入，就去了解一下。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>《重庆森林》感</title>
    <url>/2023/02/22/%E3%80%8A%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%E3%80%8B%E6%84%9F/</url>
    <content><![CDATA[<p>很深刻的，诠释了都市里人与人之间的冷漠，但也让两个人的相遇变得如此缘分与美妙。在看的时候，会感受到一种类似于自己就是海洋中的一座孤岛的孤独感。有一个作家写的小说也可以让我有一种感觉，那就是村上春树。</p>
<p>村上的小说带有太多奇幻的成分，重庆森林也带有一点奇幻感，它们都让不可思议的情节无缝衔接地发生在日常之中。第一个故事的杀手，第二个故事的”海螺姑娘“，都让这个很世俗的城市带着点荒诞。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>不要尝试多任务工作</title>
    <url>/2023/02/19/%E4%B8%8D%E8%A6%81%E5%B0%9D%E8%AF%95%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>全神贯注可以提升几乎一切体验。<br>——凯利·麦戈尼加尔，斯坦福商学院管理学讲师</p>
<p>不管技术上瘾者怎么说，多任务处理，也就是一心多用，都是不可能的。当你试图做不止一件事（比如一边读邮件一边打电话）时，你的注意力就需要在任务之间频繁切换，最终这两件事都干不好。有时你在阅读电子邮件时会暂停，听电话里的人讲话；有时你会专注于电子邮件，听不进对方的话了。跟你说话的人能够分辨出来，你显然没有把全部注意力放在他身上，你错过了重要的细节。多重任务处理并没有提高你的效率，反而降低了效率。</p>
<p>用户体验专家、火狐4浏览器的首席设计师阿萨·拉斯金（Aza Raskin）举了一个例子。把“Jewelry is shiny（珠宝是闪亮的）”这句话一个字母一个字母地大声拼读出来，同时一个字母一个字母地写下你的名字要多长时间？现在先大声拼读这句话，在说完之后再写上你的名字。你花了多长时间？可能只有多任务处理时间的一半。</p>
<p>当你尝试多个任务的时候，你犯的错误也会更多。哪怕只中断几秒钟，即切换到电子邮件程序和返回所需的时间，可能就会使你在需要集中精力的任务上所犯错误的数量增加一倍。造成错误的不仅仅是分心，来回转换也消耗精神能量，而疲劳使注意力更难集中。尽管如此，人们还是会这样做，特别是使用电脑办公的人。</p>
<p>加州大学欧文分校与微软和麻省理工学院合作的一项研究跟踪了整天上网的人的工作习惯。他们在一个任务上平均只花了47秒，就会切换到另一个任务。在一天的时间里，他们在不同的任务之间切换了400多次。一次在一件事情上花费的时间更短的人，压力水平更高，完成的工作也更少，不然没法解释他们会重复400次“切换任务”动作，而不是在每次任务完成后再去处理别的任务。除了降低生产力，高水平的压力也会导致疲劳和倦怠。</p>
<p>专注于一件任务上面，不仅可以提升效率，更重要的是，可以使大脑进入“流”的状态。经常体验这种状态可以提升一个人的幸福感、满足感。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>今天去医院看了智齿</title>
    <url>/2023/02/06/%E4%BB%8A%E5%A4%A9%E5%8E%BB%E5%8C%BB%E9%99%A2%E7%9C%8B%E4%BA%86%E6%99%BA%E9%BD%BF/</url>
    <content><![CDATA[<p>今天和小云去医院看了智齿，然后给牙齿拍了一张2D的影片。医生说牙齿还是比较好的，没有什么问题。然后对于智齿那边有点疼的问题，医生说注意清淡饮食，少熬夜就可以，它们基本已经长出来了，还是比较平整的，不用拔，lucky:blush:</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>健康</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>今天建站啦</title>
    <url>/2023/02/05/%E4%BB%8A%E5%A4%A9%E5%BB%BA%E7%AB%99%E5%95%A6/</url>
    <content><![CDATA[<p>今天把博客搭好啦！差不多搞了整整两天。</p>
<p>之前都在使用普通的Github仓库来存储技术博文，后来发现UI实在不够美观。</p>
<p>现在这个Hexo + Github Page搭建的博客有时间轴、标签、分类等，还有搜索功能~~:blush:</p>
<p>中途差点放弃，因为不熟悉遇到很多坑，想用WordPress等收费的可能会简单点（最后其实是因为那些更麻烦哈哈）</p>
<p>farewell!!</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>你不需要变得卓越</title>
    <url>/2023/03/01/%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8D%93%E8%B6%8A/</url>
    <content><![CDATA[<blockquote>
<p>“All I know is I’m losing my mind,” Franny said. “I’m just sick of ego, ego, ego. My own and everybody else’s. I’m sick of everybody that wants to get somewhere, do something distinguished and all, be somebody interesting. It’s disgusting - it is, it is. I don’t care what anybody says . . .  I’m not afraid to compete. It’s just the opposite. Don’t you see that? I’m afraid I will compete - that’s what scares me. That’s why I quit the Theater Department. Just because I’m so horribly conditioned to accept everybody else’s values, and just because I like applause and people to rave about me, doesn’t make it right. I’m ashamed of it. I’m sick of it. I’m sick of not having the courage to be an absolute nobody. I’m sick of myself and everybody else that wants to make some kind of a “splash.”</p>
</blockquote>
<p>I ‘m sick of not having the courage to be an absolute nobody.  可以翻译为：我痛恨我自己没有勇气去成为一个什么也不是的人。塞林格在上世纪就敏感地发现了现代人精神疾病的核心——the neccessary to be exceptional. Paper, movie, music and so on socia medias 无不在告诉你要变得 exceptional。</p>
<p><a href="https://www.youtube.com/watch?v=pvgfucVF5cU&list=WL&index=3&ab_channel=TheSchoolofLife">视频链接</a></p>
<p>It’s a rather simple question that quickly gets to the core of someone’s sense of well-being<br>这是一个相当简单的问题，很快就会触及一个人的幸福感</p>
<p>and legitimacy: did your childhood leave you feeling that you were - on balance - OK as<br>和存在意义的核心：你的童年是否让你觉得你 - 总的来说 - 还不错</p>
<p>you were, or did you somewhere along the way derive an impression that you needed to be<br>，或者你是否在此过程中的某个地方得到了这样的印象 您需要与众不同才能</p>
<p>extraordinary in order to deserve a place on the earth? And, to raise an associated<br>在地球上占有一席之地？ 顺便，引出一个相关的</p>
<p>question: are you therefore now relaxed about your status - or else either a manic overachiever<br>问题：因此，您现在是否对自己的地位放松了——或者是一个狂躁的超级成功者</p>
<p>or filled with shame at your so-called mediocrity?<br>，或者对您所谓的平庸感到羞耻？</p>
<p>Around twenty percent of us will be in the uncomfortable cohort, alternately refusing<br>我们中大约 20% 的人会处于不舒服的队列中，或者拒绝</p>
<p>to believe that anything could ever be enough or cursing ourselves as ‘failures’ (by<br>相信任何事情都足够，或者诅咒自己是“失败者”（</p>
<p>which we in essence mean that we have not managed to beat insane statistical odds).<br>这实际上意味着我们没有设法战胜疯狂的统计几率）。</p>
<p>At school, we probably worked very hard, not because we were drawn to the topics, but because<br>在学校，我们可能非常努力地学习，不是因为我们被这些主题所吸引，而是因为</p>
<p>we felt compelled for reasons that were - at the time - not entirely clear; we just knew<br>我们出于当时还不完全清楚的原因而感到被迫； 我们只知道</p>
<p>we had to come close at the top of the class and revise every evening. We may not be exceptional<br>我们必须接近全班第一，并且每天晚上都要复习。 我们现在可能并不例外</p>
<p>right now, but we are seldom without an acute sense of pressure to be so.<br>，但我们很少没有强烈的压力感。</p>
<p>In childhood, the story might have gone like this. A parent needed us to be special - by<br>在童年，故事可能是这样的。 父母需要我们与众不同——</p>
<p>virtue of intelligence, looks or popularity - in order to shore up a floundering sense<br>凭借智慧、外表或受欢迎程度——以支撑</p>
<p>of their own self. The child needed to achieve and could not, therefore, just be; their own<br>他们自己挣扎的自我意识。 孩子需要成就，因此不能成就； 他们自己的</p>
<p>motives and tastes were not to be part of the picture. The parent was - privately - in<br>动机和品味不会成为画面的一部分。 私下里，父母很</p>
<p>pain, unable to value themselves, battling an unnamed depression, furious with the course<br>痛苦，无法评价自己，与一种无名的抑郁症作斗争，对</p>
<p>of their own lives, perhaps covertly tortured by their spouse. And the child’s mission,<br>自己的生活感到愤怒，也许暗中受到配偶的折磨。 孩子的使命是让一切变得更好</p>
<p>for which there was no option but to volunteer, was to make it all somehow better.<br>，除了志愿服务之外别无选择。</p>
<p>It seems odd to look at achievement through this lens, not as the thing the newspapers<br>从这个角度来看成就似乎很奇怪，不是像报纸</p>
<p>tell us it is, but - very often - as a species of mental illness. Those who put up the skyscrapers,<br>告诉我们的那样，而是 - 通常 - 作为一种精神疾病。 那些盖摩天大楼、</p>
<p>write the bestselling books, perform on stage, or make partner may, in fact, be the unwell<br>写畅销书、登台表演、搭档的人，其实可能是身体不好的</p>
<p>ones. Whereas the characters who - without agony - can bear an ordinary life, the so-called<br>人。 而那些能够毫无痛苦地忍受平凡生活的人物，即所谓</p>
<p>contented ‘mediocrities’, may in fact be the emotional superstars, the aristocrats<br>知足常乐的“平庸之辈”，实际上可能是情感巨星、</p>
<p>of the spirit, the captains of the heart. The world divides into the privileged who<br>精神贵族、心灵统帅。世界分为</p>
<p>can be ordinary and the damned compelled to be remarkable.<br>可以平凡的特权者和被迫卓越的该死的人。</p>
<p>The best possible outcome for the latter is to have a breakdown. Suddenly, after years<br>后者最好的结果就是崩溃。 突然之间，经过多年</p>
<p>of achievement, they can - if they are lucky - no longer get out bed. They fall into a<br>的成就，他们可以 - 如果他们幸运的话- 不再下床。 他们陷入了</p>
<p>profound depression. They develop all-consuming social anxiety. They refuse to eat. They babble<br>深深的沮丧。 他们发展出全面的社交焦虑。 他们拒绝进食。 他们</p>
<p>incoherently. They in some way poke a very large stick in the wheels of day-to-day life<br>语无伦次地喋喋不休。 他们以某种方式在日常生活的轮子上戳了一根非常大的棍子，</p>
<p>and are allowed to stay home for a while. A breakdown is not merely a random piece of<br>并被允许留在家里一段时间。故障不仅仅是</p>
<p>madness or malfunction, it can be a very real – albeit inarticulate and inconvenient – bid<br>随机的疯狂或故障，它可以是非常真实的——尽管口齿不清和不方便——</p>
<p>for health. It is an attempt by one part of our minds to force the other into a process<br>为健康出价。 这是我们思想的一部分试图迫使另一部分进入</p>
<p>of growth, self-understanding and self-development which it has hitherto been too cowed to undertake.<br>成长、自我理解和自我发展的过程，而迄今为止，它一直被吓得无法进行。</p>
<p>If we can put it paradoxically, it is an attempt to jumpstart a process of getting well, properly<br>如果我们可以自相矛盾地说，它是试图通过病得很重的阶段，快速启动一个恢复健康、适当恢复</p>
<p>well, through a stage of falling very ill.<br>健康的过程。</p>
<p>In an apparently ill state, we might cleverly be seeking to destroy all the building blocks<br>在明显生病的状态下，我们可能会巧妙地寻求摧毁</p>
<p>of our previous driven yet unhappy careers. We may be trying to reduce our commitments<br>我们以前充满动力但不愉快的职业生涯的所有基石。我们可能正在努力减少我们的承诺</p>
<p>and our outgoings. We may be trying to throw off the cruel absurdity of others’ expectations.<br>和支出。 我们可能试图摆脱他人期望的残酷荒谬。</p>
<p>Our societies - that are often unwell at a collective and not just an individual level<br>我们的社会——通常在集体而非个人层面上表现不佳</p>
<ul>
<li>are predictably lacking in inspiring images of good enough ordinary lives. They tend to<br>——可以预见地缺乏足够好的普通生活的鼓舞人心的形象。 他们倾向于将</li>
</ul>
<p>associate these with being a loser. We imagine that a quiet life is something that only a<br>这些与失败者联系起来。 我们想象只有</p>
<p>failed person without options would ever seek. We relentlessly identify goodness with being<br>没有选择的失败者才会寻求平静的生活。我们坚持不懈地将善与处于</p>
<p>at the centre, in the metropolis, on the stage. We don’t like autumn mellowness or the peace<br>中心、大都市、舞台上相提并论。我们不喜欢秋天的柔美，也不喜欢</p>
<p>that comes once we are past the meridian of our hopes. But there is, of course, no center,<br>一旦过了我们希望的子午线就会出现的和平。 但是当然没有中心，</p>
<p>or rather the centre is oneself.<br>或者说中心就是自己。</p>
<p>Occasionally an artist will make things that bring such bathetic wisdom home. Here is Montaigne,<br>有时，艺术家会制作一些东西，将这种沐浴智慧带回家。 蒙田在他去世前几年写于 16 世纪末，</p>
<p>capturing the point in the third volume of his Essays, written a few years before his<br>在他的散文集第三卷中抓住了这一点</p>
<p>death towards the end of the sixteenth century: “Storming a breach, conducting an embassy,<br>：“冲破突破口，指挥大使馆，</p>
<p>ruling a nation are glittering deeds. Rebuking, laughing, buying, selling, loving, hating<br>统治国家都是光彩夺目的事迹。斥责，大笑， 买、卖、爱、恨</p>
<p>and living together gently and justly with your household - and with yourself - not getting<br>和与家人——以及你自己——温和公正地生活在一起——不</p>
<p>slack nor belying yourself, is something more remarkable, more rare and more difficult.<br>懈怠，不欺骗自己，是更了不起、更难得、更困难的事情。</p>
<p>Whatever people may say, such secluded lives sustain in that way duties which are at least<br>不管人们怎么说，这种与世隔绝的生活在 至少与</p>
<p>as hard and as tense as those of other lives.”<br>其他生活一样艰巨和紧张的职责。”</p>
<p>In the late 1650s, the Dutch artist Johannes Vermeer painted a picture called The Little<br>1650 年代后期，荷兰艺术家约翰内斯·维米尔 (Johannes Vermeer) 画了一幅名为《小街》的画作，至今</p>
<p>Street, that continues to challenge our value system to this day.<br>仍在挑战我们的价值体系。</p>
<p>Perhaps success might - after all - be nothing more than a quiet afternoon with the children,<br>也许成功可能——归根结底——只不过是</p>
<p>at home, in a modest street. You catch a similar point in certain stories by Chekhov or Raymond<br>在一条朴素的街道上和孩子们在家里度过一个安静的下午。在契诃夫或雷蒙德卡佛的某些故事中</p>
<p>Carver, in Bob Dylan’s Time out of Mind, in Thomas Jones’s study of A Wall in Naples<br>，在鲍勃迪伦的“精神错乱的时间”中，在托马斯琼斯对那不勒斯的墙的研究</p>
<p>(1782) and in the films of Eric Rohmer, in particular Le Rayon Vert (1982).<br>（1782 年）以及埃里克侯麦的电影中，尤其是在 Le Rayon Vert（1982 年）中，你会发现类似的观点 . 然而，</p>
<p>Most movies, adverts, songs and articles, however, do not tend to go this way, they<br>大多数电影、广告、歌曲和文章并不倾向于这样做，它们</p>
<p>continually explain to us the appeal of other things: sports cars, tropical island holidays,<br>不断地向我们解释其他事物的吸引力：跑车、热带岛屿假期、</p>
<p>fame, an exalted destiny, first-class air travel and being very busy. The attractions<br>名声、崇高的命运、头等舱的航空旅行和成为 很忙。 景点</p>
<p>are sometimes perfectly real. But the cumulative effect is to instill in us the idea that our<br>有时是完全真实的。 但累积的影响是向我们灌输这样一种观念，即我们</p>
<p>own lives must be close to worthless.<br>自己的生命必须接近一文不值。</p>
<p>And yet there may be immense skill, joy and nobility involved in what we are up to: in<br>然而，在我们所做的事情中可能蕴含着巨大的技巧、快乐和高贵：</p>
<p>bringing up a child to be reasonably independent and balanced; in maintaining a good-enough<br>培养一个孩子相当独立和平衡； 尽管存在极端困难的领域，但</p>
<p>relationship with a partner over many years despite areas of extreme difficulty; in keeping<br>多年来与合作伙伴保持足够好的关系； 保持</p>
<p>a home in reasonable order; in getting a lot of early nights; in doing a not very exciting<br>家庭秩序井然；经常早睡；</p>
<p>or well-paid job responsibly and cheerfully; in listening properly to other people and,<br>负责任和愉快地从事一份不太令人兴奋或报酬不高的工作；正确倾听他人的意见，</p>
<p>in general, in not succumbing to madness or rage at the paradox and compromises involved<br>总的来说，不屈服于对活着所涉及的悖论和妥协的疯狂或愤怒</p>
<p>in being alive.<br>。</p>
<p>There is already a treasury to appreciate in our circumstances when we learn to see<br>当我们学会在</p>
<p>these without prejudice or self-hatred. As we may discover once we are beyond others’<br>没有偏见或自我仇恨的情况下看待这些时，我们的环境中已经有一个值得欣赏的宝库。一旦我们超出了别人的期望，我们就会发现</p>
<p>expectations, life’s true luxuries might comprise nothing more or less than simplicity,<br>，生活中真正的奢侈可能不外乎就是简单、</p>
<p>quiet, friendship based on vulnerability, creativity without an audience, love without<br>安静、基于脆弱的友谊、没有观众的创造力、没有</p>
<p>too much hope or despair, hot baths and dried fruits, walnuts<br>太多希望或绝望的爱情、热水澡和干果， 核桃</p>
<p>and dark chocolate.<br>和黑巧克力。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>关键字tailrec</title>
    <url>/2023/02/27/%E5%85%B3%E9%94%AE%E5%AD%97tailrec/</url>
    <content><![CDATA[<p>chatgpt:</p>
<p>Kotlin中的<code>tailrec</code>是一个修饰符，用于声明一个递归函数，告诉编译器将其转化为尾递归函数。尾递归是一种特殊的递归形式，在每个递归调用的结尾处只返回函数本身，不再执行任何其他操作。使用尾递归可以避免栈溢出问题，因为编译器可以对尾递归进行优化，将其转换为迭代形式，从而节省了函数调用堆栈的空间。</p>
<p>使用<code>tailrec</code>的要求：</p>
<ul>
<li>函数必须是递归函数；</li>
<li>递归调用必须是函数体中的最后一个操作。</li>
</ul>
<p>下面是一个使用<code>tailrec</code>的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlinCopy codetailrec fun factorial(n: Int, acc: Int = 1): Int =</span><br><span class="line">    if (n &lt;= 1) acc</span><br><span class="line">    else factorial(n - 1, acc * n)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数<code>factorial</code>是一个尾递归函数。通过将递归调用放在函数体的最后一个操作，使用<code>tailrec</code>修饰符可以告诉编译器将其优化为迭代形式，避免了函数调用堆栈的溢出问题。</p>
<p>总之，<code>tailrec</code>修饰符适用于一些需要进行递归操作的函数，可以避免递归调用堆栈溢出的问题。但要注意，<code>tailrec</code>并不是递归的必要条件，因此只有在确定需要使用递归函数的情况下，才需要考虑使用<code>tailrec</code>来进行优化。</p>
<p>kotlin code</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Int</span>, acc: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) acc</span><br><span class="line">    <span class="keyword">else</span> factorial(n - <span class="number">1</span>, acc * n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>java decompiled code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TailoclearnKt</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">         sum += i;</span><br><span class="line">         i = var10000;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> acc)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">         acc *= n;</span><br><span class="line">         n = var10000;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kotlin</category>
        <category>语法</category>
      </categories>
  </entry>
  <entry>
    <title>协程中的NonCancellable</title>
    <url>/2023/02/12/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84NonCancellable/</url>
    <content><![CDATA[<p>NonCancellable其实是一个特殊的Job，看它的注释：</p>
<blockquote>
<p>A non-cancelable job that is always active. It is <strong>designed for withContext</strong> function to prevent cancellation of code blocks that need to <strong>be executed without cancellation</strong>.</p>
<p>（设计目的是让withContext块在取消时也可以运行）</p>
<p>Use it like this:<br>withContext(NonCancellable) {<br>    &#x2F;&#x2F; this code will not be cancelled<br>}</p>
<p>WARNING: This object is <strong>not designed</strong> to be used with <code>launch, async</code>, and other coroutine builders. if you write launch(NonCancellable) { … } then not only the newly launched job will not be cancelled when the parent is cancelled, the whole parent-child relation between parent and child is severed. The parent will not wait for the child’s completion, nor will be cancelled when the child crashed.</p>
<p>换言之，不建议在launch async上用——因为它破坏了结构化并发</p>
</blockquote>
<p>正常来说，</p>
<ol>
<li>在进入withContext块之前，如果<strong>已经cancel</strong>了，那么<strong>不会进入</strong>，</li>
<li>如果已经进入了，然后被<strong>cancel</strong>，在块中有<code>delay</code>这种可取消挂起函数，会抛出<code>cancellationException</code>结束<code>withContext</code>块</li>
<li>如果在<code>withContext</code>结束返回值的时候检测到取消，会丢弃返回值并抛出<code>cancellationException</code></li>
</ol>
<p>那么NonCancellable可以帮助它：</p>
<ol>
<li>如果<strong>已经cancel</strong>了，那么<strong>依然进入</strong></li>
<li>如果已经进入了，然后被<strong>cancel</strong>，在块中有<code>delay</code>这种可取消挂起函数，忽略</li>
<li>如果在<code>withContext</code>结束返回值的时候检测到取消，忽略</li>
</ol>
<p>换言之，不参与结构化并发。</p>
<p>其实不用<code>NonCancellable</code>，自己显示定义一个<code>Job()</code>也可以做到。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">2</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">            withContext(NonCancellable) &#123; <span class="comment">// NonCancellable / Job()</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1500</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m running finally</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">job: And I<span class="string">&#x27;ve just delayed for 1 sec because I&#x27;</span>m non-cancellable</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>协程异常处理总结</title>
    <url>/2023/02/11/%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-Job的继承关系"><a href="#1-Job的继承关系" class="headerlink" title="1. Job的继承关系"></a>1. Job的继承关系</h3><p>首先来了解kotlin协程作用域的父子关系，parent-child。先来看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler3 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    topLevelScope.launch(exceptionHandler2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch(exceptionHandler3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个协程报错，然后try&#x2F;catch<strong>没有包裹报错的代码，而是包裹报错的那个协程</strong>，那么exception并不会被catch到，也就是协程里面的exception没有re-throw，而是propagated up，沿着job的继承链向上传递。下面是上面代码的父子协程关系图：</p>
<p><img src="https://i0.wp.com/www.lukaslechner.com/wp-content/uploads/2020/08/Screenshot-2020-08-25-at-10.51.22.png?w=792&ssl=1" alt="代码的协程继承关系"></p>
<ol>
<li><p>CoroutineScope是topLevelScope，第一个launch是Top-Level Coroutine，第二个和更多被它包裹住的算是Child Coroutine.</p>
</li>
<li><p>要判断继承关系需要看Job的继承，而不是看launch，不然会错过。CoroutineScope和launch中都有一个默认的Job参数作为Context。</p>
<p>这段话解读的很好：”To make all the features of Structured Concurrency possible, the <code>Job</code> object of a <code>CoroutineScope</code> and the <code>Job</code> objects of Coroutines and Child-Coroutines form a hierarchy of parent-child relationships. An uncaught exception, instead of being re-thrown, is “propagated up the job hierarchy”. This exception propagation leads to the failure of the parent <code>Job</code>, which in turn leads to the cancellation of all the <code>Job</code>s of its children.“</p>
</li>
</ol>
<h3 id="2-ExceptionHandler的位置"><a href="#2-ExceptionHandler的位置" class="headerlink" title="2. ExceptionHandler的位置"></a>2. ExceptionHandler的位置</h3><p>在上面的代码例子中，</p>
<p>1）如果exceptionHandler1和exceptionHandler2都在，那么exception上升到exceptionHandler2就被处理了，</p>
<p>2）如果exceptionHandler1和exceptionHandler2只有任意一个，那么就由存在的那个处理。</p>
<p>3）如果exceptionHandler1和exceptionHandler2都不在，那么就会去到<strong>线程的错误处理</strong>——crash。</p>
<p>4）在一个child coroutine中安装exceptionHandler没有效果。</p>
<p>总结：<strong>In order for a <code>CoroutineExceptionHandler</code> to have an effect, it must be installed either in the <code>CoroutineScope</code> or in a top-level coroutine.</strong></p>
<p>要么</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + coroutineExceptionHandler)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>要么</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">topLevelScope.launch(coroutineExceptionHandler) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在上面的那个例子中，由topLevelScope launch的<strong>其他顶层协程</strong>都因为一个顶层协程的报错而被取消，当然这个cancel是合作式的，仅仅是发出取消的指令。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">topLevelScope.launch() &#123;</span><br><span class="line">    <span class="comment">// 发生报错</span></span><br><span class="line">&#125;</span><br><span class="line">topLevelScope.launch &#123;<span class="comment">// 被取消</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)<span class="comment">// 合作式取消</span></span><br><span class="line">        println(<span class="string">&quot;循环打印&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-async的异常处理"><a href="#3-async的异常处理" class="headerlink" title="3.  async的异常处理"></a>3.  async的异常处理</h3><p>由async启动的协程的错误处理和launch有点不同。</p>
<h4 id="1-async启动的协程是Top-Level-协程"><a href="#1-async启动的协程是Top-Level-协程" class="headerlink" title="1.async启动的协程是Top-Level 协程"></a>1.async启动的协程是Top-Level 协程</h4><p>看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">       println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 顶层async</span></span><br><span class="line">   <span class="keyword">val</span> deferred = topLevelScope.async  &#123;</span><br><span class="line">       <span class="comment">// 发生报错</span></span><br><span class="line">       <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错既不会在async处 re-throw也不会上升到handler1处理，而是会在<strong>调用await()处</strong>被re-throw。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">    println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line"><span class="keyword">val</span> topLevelScope2 = CoroutineScope(exceptionHandler2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层async</span></span><br><span class="line"><span class="keyword">val</span> deferred = topLevelScope.async  &#123;</span><br><span class="line">    <span class="comment">// 发生报错</span></span><br><span class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topLevelScope2.launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()<span class="comment">// re-throw here</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$e</span> in try/catch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>总结：这种情况，异常被封装在Deferred之中，只有在调用await处才会被re-throw。只需要在await()处调用try&#x2F;catch捕获。</p>
<h4 id="2-async启动的协程是Child协程"><a href="#2-async启动的协程是Child协程" class="headerlink" title="2.async启动的协程是Child协程"></a>2.async启动的协程是Child协程</h4><p>看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    <span class="keyword">val</span> topLevelScope2 = CoroutineScope(exceptionHandler2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deferred2: Deferred&lt;<span class="built_in">Nothing</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 顶层async</span></span><br><span class="line">    topLevelScope.launch  &#123;</span><br><span class="line">        deferred2 = async &#123;</span><br><span class="line">            <span class="comment">// 发生报错</span></span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topLevelScope2.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (deferred2 == <span class="literal">null</span>)</span><br><span class="line">                print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000</span>)</span><br><span class="line">            println(<span class="string">&quot;after 5 seconds&quot;</span>)</span><br><span class="line">            deferred2!!.await()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$e</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">800000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in handler1</span><br><span class="line">after 5 seconds</span><br><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>可以看到，async里面的报错，<strong>立即</strong>沿着Job继承链<strong>上升</strong>——propagated up，即使没调用await()，<strong>并且也会</strong>在await()处re-throw。</p>
<p>如果topLevelScope的exceptionHandler1被去掉，那么会crash，因为没有handler捕获这个上升的报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;DefaultDispatcher-worker-3&quot; java.lang.RuntimeException: RuntimeException in nested coroutine</span><br><span class="line">	at com.example.composeproject.TestKt$main$2$1.invokeSuspend(Test.kt:25)</span><br><span class="line">	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)</span><br><span class="line">	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:749)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677)</span><br><span class="line">	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664)</span><br><span class="line">	Suppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: [StandaloneCoroutine&#123;Cancelling&#125;@596502e1, Dispatchers.Default]</span><br><span class="line">after 5 seconds</span><br><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span><br></pre></td></tr></table></figure>

<p>总结：抛出异常后，</p>
<p>1）需要在Job链添加Handler捕获 </p>
<p>2）在await()处re-throw的异常也要捕获。</p>
<p>放一个表格总结一下对于Uncaught Exception(没有在协程体内被try&#x2F;catch的异常)的协程处理规律：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">launch</th>
<th align="center">async</th>
</tr>
</thead>
<tbody><tr>
<td align="center">top level Coroutine</td>
<td align="center">沿着Job上升</td>
<td align="center">被deferred包装，在await处re-throw</td>
</tr>
<tr>
<td align="center">child Coroutine</td>
<td align="center">沿着Job上升</td>
<td align="center">立刻沿着Job上升（即使不调用await），调用await时也re-throw</td>
</tr>
</tbody></table>
<h3 id="4-coroutineScope函数"><a href="#4-coroutineScope函数" class="headerlink" title="4. coroutineScope函数"></a>4. coroutineScope函数</h3><p>根据它的函数注释，提炼出一下要点：</p>
<ol>
<li><strong>Creates a CoroutineScope</strong> and calls the specified suspend block with this scope.</li>
<li>The provided scope inherits its coroutineContext from the outer scope, but <strong>overrides the context’s Job</strong>.</li>
<li>When any child coroutine in this scope fails, this scope fails and all the rest of the children are cancelled（内部block有结构化并发）</li>
<li>This function(is a <strong>suspend</strong> function) **returns as soon as the given block and all its children coroutines are completed.**（要注意，这是一个挂起函数，会阻塞调用它的协程，当它内部的结构化并发完成，这个函数才完成）</li>
<li>The method may throw a CancellationException if the current job was cancelled externally or may <strong>throw a corresponding unhandled Throwable</strong> if there is any unhandled exception in this scope (for example, from a crashed coroutine that was started with launch in this scope)（内部有异常，在这个函数调用处re-throw）</li>
</ol>
<p><strong>关键要注意的是，不要把它和 <code>CoroutineScope</code>、 <code>launch</code> 、 <code>async</code> 等启动顶层协程或子协程的非挂起函数搞混就行。</strong></p>
<p>换言之，不要被它的名字所误导，可以用try&#x2F;catch捕获它抛出的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + <span class="keyword">object</span>: CoroutineExceptionHandler &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">            <span class="keyword">get</span>() = CoroutineExceptionHandler.Key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(context: <span class="type">CoroutineContext</span>, exception: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            print(<span class="string">&quot;handle exception in coroutineexceptionhandler&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 没有try/catch就在CoroutineExceptionHandler捕获</span></span><br><span class="line">            coroutineScope &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-supervisorScope函数"><a href="#5-supervisorScope函数" class="headerlink" title="5.  supervisorScope函数"></a>5.  supervisorScope函数</h3><p>下面的代码建立了如下结构图</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>… will create the following job hierarchy:</p>
<p><img src="https://i0.wp.com/www.lukaslechner.com/wp-content/uploads/2020/08/Screenshot-2020-08-25-at-11.19.55.png?w=786&ssl=1"></p>
<p>性质和 <code>coroutineScope</code> 很类似</p>
<ol>
<li>这是一个挂起函数，会阻塞调用它的协程，当它内部的结构化并发完成，这个函数才完成</li>
</ol>
<h4 id="1-内部启动的launch-x2F-async都是-top-level-coroutine"><a href="#1-内部启动的launch-x2F-async都是-top-level-coroutine" class="headerlink" title="1. 内部启动的launch&#x2F;async都是 top-level coroutine."></a>1. 内部启动的launch&#x2F;async都是 <code>top-level</code> coroutine.</h4><p>This also means we can now install a <code>CoroutineExceptionHandler</code> in them that is actually called:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$exception</span> in CoroutineExceptionHandler&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch(coroutineExceptionHandler) &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Exception in Coroutine 2&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: Exception in Coroutine 2 in CoroutineExceptionHandler</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure>

<p>The fact that coroutines that are started directly in <code>supervisorScope</code> are <strong>top-level Coroutines</strong> also means that <code>async</code> Coroutines now encapsulate their exceptions in their <code>Deferred</code> objects …(3.1节的情况)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... other code is identical to example above</span></span><br><span class="line">supervisorScope &#123;</span><br><span class="line">    <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">        println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Exception in Coroutine 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: </span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure>

<p>… and will only be re-thrown when calling <code>.await()</code></p>
<h4 id="2-supervisorScope的一些报错逻辑"><a href="#2-supervisorScope的一些报错逻辑" class="headerlink" title="2. supervisorScope的一些报错逻辑"></a>2. supervisorScope的一些报错逻辑</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子协程异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">            delay(<span class="number">6000</span>)</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException()<span class="comment">// 不影响 1）Job3 2）supervisorScope块 的代码</span></span><br><span class="line">                println(<span class="string">&quot;Coroutine 2 end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">                delay(<span class="number">4000</span>)</span><br><span class="line">                println(<span class="string">&quot;Coroutine 3 end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            delay(<span class="number">5000</span>)</span><br><span class="line">            println(<span class="string">&quot;supervisorScope end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">80000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本身supervisorScope block异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;starting Coroutine 1&quot;</span>)</span><br><span class="line">            delay(<span class="number">6000</span>)</span><br><span class="line">            println(<span class="string">&quot;Coroutine 1 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            supervisorScope &#123;</span><br><span class="line">                <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                    println(<span class="string">&quot;starting Coroutine 2&quot;</span>)</span><br><span class="line">                    delay(<span class="number">3000</span>)</span><br><span class="line">                    println(<span class="string">&quot;Coroutine 2 end&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                    println(<span class="string">&quot;starting Coroutine 3&quot;</span>)</span><br><span class="line">                    delay(<span class="number">4000</span>)</span><br><span class="line">                    println(<span class="string">&quot;Coroutine 3 end&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                delay(<span class="number">2000</span>)</span><br><span class="line">                <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;supervisorScope block exception&quot;</span>)<span class="comment">// 1） fails the scope with all its children 2）在supervisorScope函数调用处re-throw</span></span><br><span class="line">                delay(<span class="number">6000</span>)</span><br><span class="line">                println(<span class="string">&quot;supervisorScope end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;catch excception <span class="subst">$&#123;e.message&#125;</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">80000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<table>
<thead>
<tr>
<th>内部开的协程异常</th>
<th>block块抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>由于是顶层协程，可以给它们设置ExceptionHandler</td>
<td>会在supevisorScope函数调用处re-throw</td>
</tr>
</tbody></table>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><h4 id="1。破坏Job链继承导致ExceptionHandler处理者改变"><a href="#1。破坏Job链继承导致ExceptionHandler处理者改变" class="headerlink" title="1。破坏Job链继承导致ExceptionHandler处理者改变"></a>1。破坏Job链继承导致ExceptionHandler处理者改变</h4><p><a href="https://jeckonly.github.io/2023/02/07/%E5%AD%90%E5%8D%8F%E7%A8%8B%E4%B8%8D%E8%A2%AB%E7%88%B6%E5%8D%8F%E7%A8%8B%E5%BD%B1%E5%93%8D%E7%9A%84%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5/">子协程不被父协程影响的例外情况</a></p>
<p>我之前写有文章说过这种情况。如果child coroutine的Job是显式定义一个Job()，那么它不能算是“child coroutine”了，因为它不参与它parent的结构化并发，那么在下面的代码中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> exceptionHandler1 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler2 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> exceptionHandler3 = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;</span><br><span class="line">        println(<span class="string">&quot;Handle <span class="variable">$throwable</span> in handler3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(exceptionHandler1)</span><br><span class="line">    topLevelScope.launch(exceptionHandler2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch(exceptionHandler3 + Job()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;RuntimeException in nested coroutine&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Handle <span class="variable">$exception</span> in try/catch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handle java.lang.RuntimeException: RuntimeException in nested coroutine in handler3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>单身的意义</title>
    <url>/2023/02/23/%E5%8D%95%E8%BA%AB%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>One of the most important preconditions of a good relationship is a satisfactory perspective on being single </p>
<p>The more we are happy to be on our own the more we will be able to exercise the correct degree of caution around finding a new companion</p>
<p>The Bedrock of true love is Happy singledom</p>
<blockquote>
<p>真爱的基石是快乐的单身生活</p>
</blockquote>
<p>Unfortunately, our societies do very little to help us be calm or at ease in our own company</p>
<blockquote>
<p>不幸的是，我们的社会并没有教我们如何在一个人的时候保持冷静和自在</p>
</blockquote>
<p>Singleton is framed as an involuntary depressing and always hopefully temporary State</p>
<blockquote>
<p>单身被描绘成一个不自愿的、绝望的，并且是希望尽快摆脱的临时状态。</p>
</blockquote>
<p>The notion that someone might want or need to be on their own perhaps for a long while terrifies a world shaped by Legions of silently miserable couples who need confirmation that they have not chosen the wrong path</p>
<blockquote>
<p>一个人可能想要或认为自己需要独自生活很长一段时间的想法让这个世界感到恐惧，这个世界由大量默默忍耐痛苦的夫妻组成，他们需要得到确认，证明他们没有选择错误的道路。</p>
</blockquote>
<p>To enforce the idea of what single people are missing advertisers can never have enough of showing off tantalizing images of happy couples walking hand in hand  on beaches </p>
<p>And most entertainment venues, holiday destinations, and social occasions feel compelled to patronize overcharge, and otherwise demean anyone who has the impudence to venture out on their own</p>
<blockquote>
<p>大多数娱乐场所, 度假胜地和社交场合都觉得有必要对那些胆敢自己冒险的人收更多的费用，否则就会贬低那些人</p>
</blockquote>
<p>Unfortunately being miserable while single fatally undermines our judgment about who we might get together with </p>
<p>When someone is starving they will eat anything </p>
<p>Dostoyevsky wrote a harrowing short story about a famished child who eats a candle made of pig fat and we’re equally liable in emotional desperation to run into the nearest nightclub to secure a chump and will be appalled to find beside us at Daybreak </p>
<p>We eventually learn being in an unsatisfactory relationship is clearly worse </p>
<p>That is even more lonely than being alone </p>
<p>The central challenge of being alone is coping with the fear of what singlehood means </p>
<p>Being alone is bearable in relation to how normal that highly nebulous yet highly influential concept the condition feels to us at any given point </p>
<blockquote>
<p>孤独是可以忍受的，但这和”孤独“这种高度模糊但极具影响力的概念在任何特定时刻对我们的感觉有多正常相关。</p>
</blockquote>
<p>It can either be a break from an honorably busy life or sure evidence that we are an unwanted wretched disgusting and emotionally diseased being</p>
<blockquote>
<p>它可以看作是繁忙生活中的休憩，也可以用来去证明我们是一个不受欢迎的、令人厌恶的、情感上有疾病的人。</p>
</blockquote>
<p>This is tricky but ultimately very hopeful for it suggests that if only we could work on what being alone means to us we could theoretically endure long periods alone.</p>
<p>To build ourselves a new mental model of what being alone should truly mean we might rehearse a few of the following arguments</p>
<ol>
<li>Despite what an unfriendly voice inside our heads might tell us,  we are the ones who can choose whether or not to be alone</li>
</ol>
<p>Our solitude is willed rather than imposed </p>
<p>No one ever needs to be alone so long as they don’t mind who they are with, but we do mind the wrong kind of company is a great deal lonelier for us than being by ourselves </p>
<p>That is, it’s further from what matters to us more grating in its insincerity and more of a reminder of disconnection and misunderstanding than is the conversation we can have in the quiet of our own minds</p>
<blockquote>
<p>也就是说，它离我们真正关心的东西更遥远，它的虚伪更令人讨厌，它更提醒我们，与我们在自己内心平静的对话相比，它是一种脱节和误解</p>
</blockquote>
<p>Being alone is not proof that we have been rejected by the world </p>
<blockquote>
<p>独自一人并不代表被这个世界所拒绝</p>
</blockquote>
<p>It’s a sign that we’ve taken a good look at the available options and have -with wisdom- done some rejecting ourselves </p>
<blockquote>
<p>反而表明，我们曾经好好地审视了可以做出的选择，并且明智地选择了”不“</p>
</blockquote>
<p>Another big thought is that we need to appreciate how long it will take to find someone given how choosy we are for very good reasons </p>
<p>We aren’t just looking for anyone</p>
<p>The right candidate will be no less easy to find than a great job or a beautiful house</p>
<p>It might take many months probably years </p>
<p>Expectations matter </p>
<p>If we regard a decade as a plausible time frame then six months we’ll Skip by</p>
<p>There is no better guarantee of a successful relationship than knowing that we could and can manage perfectly well on our own</p>
<p>It means that we will only look for someone who can deeply contribute to our life not someone who can do the laundry with us or keep us company on Sunday evenings </p>
<blockquote>
<p>这意味着我们只会寻找一个可以深深地融入我们生命的人，而不是一个能和我们一起洗衣服或在周日晚上陪伴我们的人</p>
</blockquote>
<p>This gives us the strength to back out of unsatisfactory unions as quickly as we should </p>
<blockquote>
<p>这给了我们力量去尽早地离开一段不满意的关系</p>
</blockquote>
<p>Being a couple can’t and shouldn’t mean that we are utterly reliant on the other for our self-esteem, our daily self-management or for the meeting of our domestic needs </p>
<blockquote>
<p>成为一对夫妻不能也不应该意味着我们把自尊、日常自我管理或感受家庭的心理需求完全托付给对方</p>
</blockquote>
<p>When we have under our belt a significant experience of thriving on our own we will be able to cope with the inevitable points at which even a very nice partner can’t sustain us </p>
<blockquote>
<p>当我们拥有独自茁壮成长的深刻经验时，我们将能够应对一些即使是一个很好的伴侣也无法给予援手的坎</p>
</blockquote>
<p>We’ll be less demanding , more competent and more forensic in what we seek from a lover </p>
<p>It turns out that our willingness to stay on our own is what centrally predicts how likely we’ll be to find and bring to fruition a relationship with someone else </p>
<p>Being at ease with being single is the needed secure platform from which to make a sane and wise choice about who to create a joint life with</p>
<p><a href="https://www.youtube.com/watch?v=aAnTwyCJdf0&t=168s&ab_channel=TheSchoolofLife">视频版</a></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>协程互斥-Mutex</title>
    <url>/2023/02/13/%E5%8D%8F%E7%A8%8B%E4%BA%92%E6%96%A5-Mutex/</url>
    <content><![CDATA[<h2 id="以细粒度限制线程"><a href="#以细粒度限制线程" class="headerlink" title="以细粒度限制线程"></a>以细粒度限制线程</h2><p><em>限制线程</em> 是解决共享可变状态问题的一种方案：对特定共享状态的所有访问权都限制在单个线程中。它通常应用于 UI 程序中：所有 UI 状态都局限于单个事件分发线程或应用主线程中。这在协程中很容易实现，通过使用一个单线程上下文：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">massiveRun</span><span class="params">(action: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">100</span>  <span class="comment">// 启动的协程数量</span></span><br><span class="line">    <span class="keyword">val</span> k = <span class="number">1000</span> <span class="comment">// 每个协程重复执行同一动作的次数</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">// 协程的作用域</span></span><br><span class="line">            repeat(n) &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    repeat(k) &#123; action() &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed <span class="subst">$&#123;n * k&#125;</span> actions in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">val</span> counterContext = newSingleThreadContext(<span class="string">&quot;CounterContext&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        massiveRun &#123;</span><br><span class="line">            <span class="comment">// 将每次自增限制在单线程上下文中</span></span><br><span class="line">            withContext(counterContext) &#123;</span><br><span class="line">                counter++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Counter = <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>这段代码运行非常缓慢，因为它进行了 <em>细粒度</em> 的线程限制。每个增量操作都得使用 <code>withContext(counterContext)</code> 块从多线程 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a> 上下文切换到单线程上下文。</p>
<h2 id="以粗粒度限制线程"><a href="#以粗粒度限制线程" class="headerlink" title="以粗粒度限制线程"></a>以粗粒度限制线程</h2><p>在实践中，线程限制是在大段代码中执行的，例如：状态更新类业务逻辑中大部分都是限于单线程中。下面的示例演示了这种情况， 在单线程上下文中运行每个协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">massiveRun</span><span class="params">(action: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">100</span>  <span class="comment">// 启动的协程数量</span></span><br><span class="line">    <span class="keyword">val</span> k = <span class="number">1000</span> <span class="comment">// 每个协程重复执行同一动作的次数</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">// 协程的作用域</span></span><br><span class="line">            repeat(n) &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    repeat(k) &#123; action() &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed <span class="subst">$&#123;n * k&#125;</span> actions in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">val</span> counterContext = newSingleThreadContext(<span class="string">&quot;CounterContext&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 将一切都限制在单线程上下文中</span></span><br><span class="line">    withContext(counterContext) &#123;</span><br><span class="line">        massiveRun &#123;</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Counter = <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>这段代码运行更快而且打印出了正确的结果。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>该问题的互斥解决方案：使用<strong>永远不会同时执行</strong>的 <em>关键代码块</em> 来保护共享状态的所有修改。在阻塞的世界中，你通常会为此目的使用 <code>synchronized</code> 或者 <code>ReentrantLock</code>。 在协程中的替代品叫做 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html">Mutex</a> 。它具有 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html">lock</a> 和 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html">unlock</a> 方法， 可以隔离关键的部分。关键的区别在于 <code>Mutex.lock()</code> 是一个挂起函数，它不会阻塞线程。（但会挂起协程）</p>
<p>还有 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html">withLock</a> 扩展函数，可以方便的替代常用的 <code>mutex.lock(); try &#123; …… &#125; finally &#123; mutex.unlock() &#125;</code> 模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">massiveRun</span><span class="params">(action: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">100</span>  <span class="comment">// 启动的协程数量</span></span><br><span class="line">    <span class="keyword">val</span> k = <span class="number">1000</span> <span class="comment">// 每个协程重复执行同一动作的次数</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        coroutineScope &#123; <span class="comment">// 协程的作用域</span></span><br><span class="line">            repeat(n) &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    repeat(k) &#123; action() &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed <span class="subst">$&#123;n * k&#125;</span> actions in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        massiveRun &#123;</span><br><span class="line">            <span class="comment">// 用锁保护每次自增</span></span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                counter++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Counter = <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br></pre></td></tr></table></figure>

<p>此示例中锁是细粒度的，因此会付出一些代价。但是对于某些必须定期修改共享状态的场景，它是一个不错的选择，但是没有自然线程可以限制此状态。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>子协程不被父协程影响的例外情况</title>
    <url>/2023/02/07/%E5%AD%90%E5%8D%8F%E7%A8%8B%E4%B8%8D%E8%A2%AB%E7%88%B6%E5%8D%8F%E7%A8%8B%E5%BD%B1%E5%93%8D%E7%9A%84%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>协程中的所谓 <strong>结构化并发</strong>，就是指 <strong>父协程和子协程一起有组织有预谋地合作干活</strong>，如果不讨论<code>scupervisorScope&#123;&#125;</code>的话，大致上内涵如下：</p>
<ol>
<li>子协程fail——报错，父协程和其他子协程都cancel.</li>
<li>子协程cancel，父协程和其他子协程<strong>没事</strong>。</li>
<li>父协程fail，它所有子协程cancel。</li>
<li>父协程cancel，它所有子协程cancel。</li>
</ol>
<blockquote>
<p>子协程指<code>CoroutineScope</code>.launch&#x2F;async调用的结果。为避免混乱，不讨论 <code>coroutineScope</code>\ <code>supervisorScope</code>。</p>
</blockquote>
<p><a href="https://gist.github.com/JeckOnly/646ee60e16591468c405f59d8245880d">上面四个情况的案例</a></p>
<p>但也有例外，</p>
<p>当一个协程被其它协程在 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中启动的时候， 它将通过 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html">CoroutineScope.coroutineContext</a> 来承袭上下文(除了Job会是一个新实例，其他的例如调度器都继承下来)，并且这个新协程的 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 将会成为父协程作业的子Job。当一个父协程被取消的时候，所有它的子协程也会被递归的取消。</p>
<p>However, this parent-child relation can be explicitly overriden in one of two ways:</p>
<ol>
<li>When a different scope is explicitly specified when launching a coroutine (for example, <code>GlobalScope.launch</code>), then it does not inherit a <code>Job</code> from the parent scope.</li>
<li>When a different <code>Job</code> object is passed as the context for the new coroutine (as shown in the example below), then it overrides the <code>Job</code> of the parent scope.</li>
</ol>
<p>In both cases, the launched coroutine is not tied to the scope it was launched from and operates independently.</p>
<p>第一种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// 一个TopLevelScope</span></span><br><span class="line">        CoroutineScope(context = Dispatchers.Default).launch &#123;</span><br><span class="line">            println(<span class="string">&quot;NewTopLevelScope job1: I run in my own Job and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;NewTopLevelScope job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 另一个则承袭了父协程的上下文</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;ChildCoroutine job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;ChildCoroutine job2: I will not execute this line if my parent request is cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// 取消请求（request）的执行</span></span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 主线程延迟一秒钟来看看发生了什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">NewTopLevelScope job1: I run <span class="keyword">in</span> my own Job and execute independently!</span><br><span class="line">ChildCoroutine job2: I am a child of the request coroutine</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">NewTopLevelScope job1: I am not affected <span class="keyword">by</span> cancellation of the request</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动一个协程来处理某种传入请求（request）</span></span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="comment">// 生成了两个子作业</span></span><br><span class="line">        launch(Job()) &#123;</span><br><span class="line">            println(<span class="string">&quot;job1: I run in my own Job and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 另一个则承袭了父协程的上下文</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I will not execute this line if my parent request is cancelled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel() <span class="comment">// 取消请求（request）的执行</span></span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 主线程延迟一秒钟来看看发生了什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">job1: I run <span class="keyword">in</span> my own Job and execute independently!</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">job1: I am not affected <span class="keyword">by</span> cancellation of the request</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>要注意，无论如何，子协程的Job都是一个新实例，和Parent的Job不是同一个实例。我想区别在于 <strong>隐式创建时</strong> 带上了一些父子协程的信息。</p>
<p>参考资料：<a href="https://book.kotlincn.net/text/coroutine-context-and-dispatchers.html">协程上下文和调度器</a></p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>去年春天的阴霾</title>
    <url>/2023/02/25/%E5%8E%BB%E5%B9%B4%E6%98%A5%E5%A4%A9%E7%9A%84%E9%98%B4%E9%9C%BE/</url>
    <content><![CDATA[<p>我不想去写，但有这个必要去回忆。</p>
<p>在《东邪西毒》开头，张国荣饰演的欧阳锋有一句台词：看来你的年纪也有四十出头了，这四十多年来，总有些事你是不愿再提，或是有些人你不想再见，有的人曾经对不起你。</p>
<p>其实不用四十出头，从十多岁开始，每个人都有一些纠葛的事，不愿想起来。可越是不想回忆起来，就越难以忘记。欧阳锋喝了醉生梦死尚且忘不了，何况我今天没喝酒。只喝了一瓶250ml的纯牛奶。</p>
<p>那是去年春天的事，差不多上一年的这个时候。我去到一个陌生的环境，但不得不去适应它。我以为我对我的情绪和行为控制良好，但每过一段时间去看，都是漏洞百出，里面满是焦虑不安，自卑怨恨，和爱的人的争执。不用说，伤害她已是一个事实，她没忘记，我也没忘记。</p>
<p>其实还有一些人，当初也是把酒言欢。但就像我许久不肯面对当初的我一般，渐渐没了联系。我也不清楚是不是仅仅没联系我，如果是的话，反而能让我接受，的确做了一些幼稚的事情。</p>
<p>”每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。“</p>
<p>去年春天的山，到底有没有翻过去，在现在看来，是没有的。或许在以后会发现，我已在山的另一边。但山后面还有山。</p>
<p>”小时候总想知道沙漠那边是什么，走过去，才知道沙漠那边还是沙漠。“</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>小云第一局Valorant</title>
    <url>/2023/02/06/%E5%B0%8F%E4%BA%91%E7%AC%AC%E4%B8%80%E5%B1%80Valorant/</url>
    <content><![CDATA[<p>小云今天完完整整地打了一局Valorant，之前都是零零碎碎地打。不得不说对于一个新手来说，还行。不过我们也是今天她玩了才知道她晕三D，她说吃饭时都没啥胃口。我也是第一次实际看到晕三D的情况。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>小云</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Moshi</title>
    <url>/2023/02/21/%E5%AD%A6%E4%B9%A0Moshi/</url>
    <content><![CDATA[<h1 id="vs-Gson"><a href="#vs-Gson" class="headerlink" title="vs Gson"></a>vs Gson</h1><p>Gson的仓库介绍：Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. </p>
<p>Gson专门用于Java。</p>
<p>Moshi的介绍：Moshi is a modern JSON library for Android, Java and Kotlin. It makes it easy to parse JSON into Java and Kotlin classes.</p>
<p>在开始学习之前，有理由推测 Moshi针对Kotlin做了一些提升，可以做到Gson对Kotlin所做不到的功能。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>) version <span class="string">&quot;1.8.10&quot;</span></span><br><span class="line">    java</span><br><span class="line">    kotlin(<span class="string">&quot;kapt&quot;</span>) version <span class="string">&quot;1.8.10&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Moshi</span></span><br><span class="line">implementation(<span class="string">&quot;com.squareup.moshi:moshi:1.14.0&quot;</span>)</span><br><span class="line">implementation(<span class="string">&quot;com.squareup.moshi:moshi-kotlin:1.14.0&quot;</span>)<span class="comment">// 包含KotlinJsonAdapterFactory()，可使用反射的方式序列化Kotlin 类</span></span><br><span class="line">kapt(<span class="string">&quot;com.squareup.moshi:moshi-kotlin-codegen:1.14.0&quot;</span>) <span class="comment">// 使用codegen的方式序列化 Kotlin 类</span></span><br></pre></td></tr></table></figure>

<p>反射和codegen必须使用<strong>其一或都使用</strong>。不然会报错。</p>
<ul>
<li>使用反射添加<code>KotlinJsonAdapterFactory</code></li>
<li>使用codegen在类添加 <code>@JsonClass(generateAdapter = true)</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/58501918/whats-the-use-of-moshis-kotlin-codegen">使用反射或codegen的不同</a></p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>基本代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">BlackjackHand</span>(</span><br><span class="line">    <span class="keyword">val</span> hidden_card: Card,</span><br><span class="line">    <span class="keyword">val</span> visible_cards: List&lt;Card&gt;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Card</span>(</span><br><span class="line">    <span class="keyword">val</span> rank: <span class="built_in">Char</span>,</span><br><span class="line">    <span class="keyword">val</span> suit: Suit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Suit</span> &#123;</span><br><span class="line">    CLUBS, DIAMONDS, HEARTS, SPADES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;hidden_card&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;rank&quot;: &quot;6&quot;,</span></span><br><span class="line"><span class="string">        &quot;suit&quot;: &quot;SPADES&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &quot;visible_cards&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;rank&quot;: &quot;4&quot;,</span></span><br><span class="line"><span class="string">          &quot;suit&quot;: &quot;CLUBS&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;rank&quot;: &quot;A&quot;,</span></span><br><span class="line"><span class="string">          &quot;suit&quot;: &quot;HEARTS&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> moshi: Moshi = Moshi.Builder()</span><br><span class="line">    .addLast(KotlinJsonAdapterFactory())</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<h2 id="from-json"><a href="#from-json" class="headerlink" title="from json"></a>from json</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from json</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jsonAdapter: JsonAdapter&lt;BlackjackHand&gt; = moshi.adapter(BlackjackHand::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="comment">// val jsonAdapter: JsonAdapter&lt;BlackjackHand&gt; = moshi.adapter() 实验性</span></span><br><span class="line">    <span class="keyword">val</span> blackjackHand = jsonAdapter.fromJson(json)</span><br><span class="line">    println(blackjackHand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="to-json"><a href="#to-json" class="headerlink" title="to json"></a>to json</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to json</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> blackjackHand = BlackjackHand(</span><br><span class="line">        Card(<span class="string">&#x27;6&#x27;</span>, Suit.SPADES),</span><br><span class="line">        listOf(Card(<span class="string">&#x27;4&#x27;</span>, Suit.CLUBS), Card(<span class="string">&#x27;A&#x27;</span>, Suit.HEARTS))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jsonAdapter: JsonAdapter&lt;BlackjackHand&gt; = moshi.adapter(BlackjackHand::<span class="keyword">class</span>.java)</span><br><span class="line">	<span class="comment">// val jsonAdapter: JsonAdapter&lt;BlackjackHand&gt; = moshi.adapter() 实验性</span></span><br><span class="line">    <span class="keyword">val</span> json: String = jsonAdapter.toJson(blackjackHand)</span><br><span class="line">    println(json)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="parse-array"><a href="#parse-array" class="headerlink" title="parse array"></a>parse array</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrayJson = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        [</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            &quot;rank&quot;: &quot;4&quot;,</span></span><br><span class="line"><span class="string">            &quot;suit&quot;: &quot;CLUBS&quot;</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            &quot;rank&quot;: &quot;A&quot;,</span></span><br><span class="line"><span class="string">            &quot;suit&quot;: &quot;HEARTS&quot;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> adapter: JsonAdapter&lt;List&lt;Card&gt;&gt; = moshi.adapter()<span class="comment">// 实验性方法</span></span><br><span class="line">    <span class="keyword">val</span> cards: List&lt;Card&gt;? = adapter.fromJson(arrayJson)</span><br><span class="line">    print(cards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="报错规则"><a href="#报错规则" class="headerlink" title="报错规则"></a>报错规则</h1><p>Moshi always throws a standard <code>java.io.IOException</code> if there is an error reading the JSON document, or if it is malformed. It throws a <code>JsonDataException</code> if the JSON document is well-formed, but doesn’t match the expected format.</p>
<h1 id="自定义字段名"><a href="#自定义字段名" class="headerlink" title="自定义字段名"></a>自定义字段名</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> username: String</span><br><span class="line">  <span class="meta">@Json(name = <span class="string">&quot;lucky number&quot;</span>)</span> <span class="keyword">val</span> luckyNumber: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="忽略字段"><a href="#忽略字段" class="headerlink" title="忽略字段"></a>忽略字段</h1><p>By default, all fields are emitted when encoding JSON, and all fields are accepted when decoding JSON. Prevent a field from being included by annotating them with <code>@Json(ignore = true)</code>.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlackjackHand</span>(...) &#123;</span><br><span class="line">  <span class="meta">@Json(ignore = true)</span></span><br><span class="line">  <span class="keyword">var</span> total: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>These fields are omitted when writing JSON. When reading JSON, the field is skipped even if the JSON contains a value for the field. Instead, it will get a default value. In Kotlin, these fields <em>must</em> have a default value if they are in the primary constructor.</p>
<p>Note that you can also use Java’s <code>transient</code> keyword or Kotlin’s <code>@Transient</code> annotation on these fields for the same effect.</p>
<h1 id="自定义适配器"><a href="#自定义适配器" class="headerlink" title="自定义适配器"></a>自定义适配器</h1><p><a href="https://github.com/square/moshi#custom-type-adapters">https://github.com/square/moshi#custom-type-adapters</a></p>
<p><a href="https://github.com/square/moshi#alternate-type-adapters-with-jsonqualifier">https://github.com/square/moshi#alternate-type-adapters-with-jsonqualifier</a></p>
<h1 id="Retrofit2-Gson迁移至Moshi"><a href="#Retrofit2-Gson迁移至Moshi" class="headerlink" title="Retrofit2 Gson迁移至Moshi"></a>Retrofit2 Gson迁移至Moshi</h1><p>如果没有自定义适配器和自定义字段名，直接更改就好</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">addConverterFactory(MoshiConverterFactory.create())</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.cn/post/6969841959082917901">掘金</a></p>
<p><a href="https://github.com/square/moshi">moshi github readme</a></p>
<p><a href="https://juejin.cn/post/7041076820849983518#heading-5">掘金2</a></p>
]]></content>
      <categories>
        <category>库</category>
        <category>Moshi</category>
      </categories>
  </entry>
  <entry>
    <title>爱情如何持久化</title>
    <url>/2023/03/01/%E7%88%B1%E6%83%85%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>爱是一种需求，一种渴望，是探寻生命中最大奖赏的驱动力。——海伦·费希尔，生物人类学家</p>
</blockquote>
<p>我认为要探求情感的本质，很大程度上还是靠精神分析学和脑生理学。前者探寻为什么一个人要拥有这样那样的情感，后者揭示情感如何工作。</p>
<p>生理学家认为，爱情初期的激情和所谓坠入爱河的感觉，来源于奖赏预测误差带来的丰富的多巴胺。而多巴胺又驱使着人们去追求新鲜，追求更多。</p>
<p>多巴胺是面向未来的，但大脑中也有另外一种被称为“当下分子”的物质，它让人们产生满足感，即那种“活在当下”的感觉。爱情持久化的关键在于如何让感情从“多巴胺驱动”转变为“当下分子驱动”。</p>
<p>似乎这与基因有关，一个“”多巴胺能“丰富的人，生活中一般更有激情，更不容易满足，在爱情上，往往关系都不会长久，在12-18个月的激情期消退之后，当下的感情已没有新鲜感了。大脑告诉他，你已经对Ta没有感觉了，是时候寻找一个有感觉的人。于是一个新的 loop 开始。</p>
<blockquote>
<p>从多巴胺的角度来说，拥有是无趣的，只有获得才有趣。如果你生活在桥下，多巴胺会让你想获得一顶帐篷。如果你生活在帐篷里，多巴胺就会让你想获得一栋房子。如果你住在世界上最贵的豪宅中，多巴胺会让你想获得月球上的城堡。多巴胺不会满足于某一个标准，追求也永无止境。大脑中的多巴胺回路只能被光鲜之物的可能性所刺激，而不管现在的事物已有多完美。多巴胺的座右铭是“想要更多”。</p>
</blockquote>
<p>多巴胺是爱的煽动者之一，是引发一切火花的来源。但要让爱超越那个阶段，恋爱关系的本质就必须改变，因为它背后的“化学交响曲”会改变。毕竟多巴胺不是快乐分子，它是预期分子。为了享受我们拥有的东西，而不是仅仅可能得到的东西，我们的大脑必须从面向未来的多巴胺过渡到面向现在的当下分子。</p>
<p>下面摘抄一段《贪婪的多巴胺的原文》</p>
<blockquote>
<p>我们称之为“当下分子”。大多数人都对它们的名字略有耳闻，包括血清素、催产素、内啡肽（相当于大脑自产的吗啡）和内源大麻素（相当于大脑自产的大麻）。与通过多巴胺得到的来自预期的愉悦相反，这些化学物质会给我们带来由感觉和情感引发的愉悦。花生四烯酸乙醇胺是内源性大麻素的一种，它的英文名称anandamide就源于表示欢乐、狂喜和高兴的梵语单词。</p>
<p>根据人类学家海伦·费希尔的说法，早期爱情或者说“激情之爱”只会持续12~18个月。在那之后，一对情侣要保持对彼此的依恋就需要发展出一种不同的爱，这被称为“陪伴之爱”。陪伴之爱是由当下分子调节的，因为它涉及发生在此时此地的经历——既然你和你爱的人在一起，就好好享受吧。陪伴之爱不是人类独有的现象，在为了繁衍而结成配偶的动物中也可以观察到。</p>
<p>结为配偶的动物会守卫自己的领地并一起筑巢，还会互相喂食、梳毛，一起分担养育下一代的事务。最重要的是，它们会待在对方附近，分开的时候会表现出焦虑。这些行为和人类是一样的。人类会从事类似的活动并有类似的感觉，与另一个人的生活紧密地交织在一起也会带来满足感。</p>
<p>在爱情的第二阶段，当下分子掌握了主导权，多巴胺会被抑制。大脑必须这么做，因为多巴胺在我们脑海中描绘了一幅色彩斑斓的未来图景，鞭策我们不断努力使之成为现实。对当前形势的不满是导致变化的一个重要因素，这就是一段<strong>新感情的全部意义</strong>所在。另外，当下的陪伴之爱表示你对当前现实十分满足，厌恶改变，至少在伴侣关系方面如此。事实上，尽管多巴胺和当下分子的回路能一起工作，但在大多数情况下它们是相互<strong>对抗</strong>的。在当下分子回路被激活时，我们更喜欢体验周围的真实世界，多巴胺就会被抑制；而当多巴胺回路被激活时，我们则进入一个充满可能性的未来，当下分子会被抑制。实验室的测试证明了这个结论。科学家们观察了从处于热恋中的人身上提取的血细胞，发现血清素受体的水平比“健康人”要低，这表明当下分子受到了抑制。</p>
<p>告别让人另寻新欢和渴求激情的多巴胺并不容易，但拥有这方面的能力是成熟的标志，也是迈向持久幸福的一步。假设一个人计划去罗马度假，他花了几个星期安排每日行程，以确保走遍他所熟知的每一个博物馆和地标。但在他置身于这些最绚丽的艺术品中时，他却在想着如何去已经预订了晚餐的餐厅。他并不是对米开朗琪罗的杰作不感兴趣，只是他的性格是由多巴胺主导的：他热衷于期待和计划，而不是实施。</p>
<p>情侣们也在期待和体验之间经历着同样的脱节。早期的爱情，也就是激情之爱是多巴胺主导的——使人兴奋、理想化、好奇，并关注未来。后一阶段的陪伴之爱则是由当下分子主导的——使人满足、心平气和，并通过身体的感官和情感去体验。</p>
<p>建立在多巴胺基础上的浪漫关系是一段令人兴奋但短暂的过山车之旅，然而我们大脑中的化学过程也为我们铺平了通往陪伴之爱的道路。多巴胺代表着痴迷与渴望，而与长期关系最相关的化学物质则是催产素和血管升压素。催产素在女性中更活跃，而血管升压素在男性中更活跃。</p>
<p>科学家们在实验室里对各种动物的神经递质进行了研究。例如，科学家将催产素注射到雌性草原田鼠的大脑中以后，它们会立刻与周围的某只雄性田鼠形成<strong>长期关系</strong>。类似地，研究人员通过基因编辑制造出了具有滥交倾向的雄性田鼠，又给它们增加了一个增强血管升压素的基因时，发现它们在有多个雌性田鼠可供交配时，也只与某一只雌性田鼠交配。血管升压素就像一种“好丈夫激素”，而多巴胺则相反。具有能产生高水平多巴胺的基因的人拥有的性伴侣数更多，首次性交年龄也更低。</p>
<p>随着多巴胺驱动的热烈爱情演变成当下分子主导的陪伴之爱，大多数情侣或夫妇的性生活频率会降低。这是合理的，因为催产素和血管升压素会抑制睾酮的释放。反过来，睾酮也抑制催产素和血管升压素的释放，这也解释了为什么血液中睾酮含量高的男性结婚的可能性较小。同样，单身男性比已婚男性睾酮含量更高。如果一个男人的婚姻变得不稳定，他的血管升压素会下降，睾酮会上升。</p>
<p>人类需要长期的伴侣吗？有很多证据表明答案是肯定的。尽管拥有多个伴侣表面上很有吸引力，大多数人最终还是选择安定下来。联合国的一项调查发现，90%以上的人会在49岁之前结婚。我们可以在没有陪伴之爱的情况下生活，但大多数人都会付出人生中相当一部分的时间精力来寻找并维护它。当下分子为我们赋予了这样做的能力。它们让我们从感官传达给我们的感受中得到满足感——包括我们面前的事物，以及我们可以即刻体验，而不会一直欲求不满的事物</p>
</blockquote>
<p>显然，爱情能否在蜜月期之后依然可以存活下去，在于能否让感情从“多巴胺驱动”转变为“当下分子驱动”。但似乎一个人的”多巴胺能“是否活跃，是被基因所决定的了，很难改变。</p>
<p>《春光乍泄》中的何宝荣，就是一个典型的”多巴胺能“大脑。他虽然喜欢黎耀辉，但他更被纸醉金迷和新鲜感所吸引，一次次离开，又一次次回来，但回来之后又是新的离开。</p>
<p>黎耀辉则是”当下分子“主导的人，他说，在何宝荣生病时，照顾他的那段时光是和他在一起最快乐的时光。黎对于当下的感受和从中得到的幸福感远比何宝荣强烈。</p>
<p>在现实中，浪荡的人的一般都不会是沉闷的人，往往比有固定关系的人更活跃。毕竟多巴胺不仅仅影响爱情。</p>
<p>那方法论是什么，即如何从躁动沉淀到满足？科学家可没有给出答案。但就像大脑额叶丰富带来更强的逻辑思维，更多的运用逻辑思维也可以锻炼大脑额叶。让自己的大脑中的”当下分子“占据主导并不是不可能。</p>
<p>我想可以从加强对当下关系的感受开始，加强自己对”当下分子“作用的敏感度，减少大脑多巴胺的水平。</p>
<p>但过于无聊的难以忍受也是往往难以坚持，毕竟多巴胺就想要”新鲜“，不一样的事物。所以爱情当中的新鲜感就像喂给多巴胺这只野兽的甜食一般——要学会从恋人身上挖掘新鲜感或创造新鲜感。</p>
<blockquote>
<p>虽然封面照用了泰坦尼克号，但you jump I jump可不是真正的爱情，我认为它只能是一部”激情电影“，算不上”爱情电影“，它们只是被多巴胺驱动着，在进行”激素蹦迪“而已。蹦迪结束，大多数人都分道扬镳，也是大多数情侣的写照。</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>最近关于多巴胺的一点思考</title>
    <url>/2023/02/07/%E6%9C%80%E8%BF%91%E5%85%B3%E4%BA%8E%E5%A4%9A%E5%B7%B4%E8%83%BA%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>我想多巴胺可以根据如何触发的分为 内源性多巴胺和外源性多巴胺。内源性多巴胺是在完成了一些困难的任务，或相对的来说和如今的触手可及的娱乐活动相比“不那么愉悦”的活动，或经历了伤痛之后，大脑为了恢复pleasure \ pain的平衡而分泌的多巴胺。外源性的多巴胺则是在“上瘾”的驱动下释放的多巴胺，比如吃巧克力，玩电子游戏（注意，这些活动对一些人来说可能如工作一般乏味，我指的是对认为它们具有巨大诱惑力的人来说）。外源性的多巴胺往往在短时间内可以让人获得比较大的愉悦，但过后往往是痛苦，并且还会有更深层次的危险——在生理层面上改变大脑对快乐和痛苦的感受，使得痛苦越来越敏感，快乐需要更大的刺激才能达到以前小小的刺激就可以达到的水平；在日常状态下，大脑中快乐和痛苦的“跷跷板”不是趋于平衡，而是限于水平之下，即忧郁和焦虑。这也是《Dopamine Nation》的作者认为现代人普遍焦虑、抑郁和失眠的原因。</p>
<blockquote>
<p>人类有接近快乐和避免痛苦的习惯。这是一种本能，可以追溯到数百万年前，那时人们需要每天积极寻找食物、衣服和住所，否则就会面临死亡风险。</p>
<p>但是精神病学家安娜·伦布克他说，在当今世界，这样的基本需求往往是现成的，这改变了等式。</p>
</blockquote>
<p>诱惑太多，释放外源性多巴胺对于现代人来说过于容易，这也改变了大脑的快乐痛苦平衡。</p>
<blockquote>
<p><strong>关于大脑中快乐和痛苦处理是如何重叠的</strong></p>
<p>过去75年来，神经科学最令人着迷的发现之一是，大脑中处理快乐的相同区域也处理痛苦，快乐和痛苦就像一种平衡。所以，如果你想象一下，在你的大脑中有一个跷跷板，就像你在孩子们的操场上看到的一样，当摇摇晃荡的东西处于静止基线时，它与地面是平的。当我们做一些令人愉快的事情时——例如，当我吃一块巧克力时——我的快乐&#x2F;痛苦平衡会稍微偏向快乐的一边，我的大脑的奖赏途径中会释放多巴胺。</p>
<p>但调节这种平衡的一个主要原则是，它希望保持水平，这就是神经科学家所说的 <strong>稳态</strong> 它不想偏离太长时间，无论是快乐还是痛苦。因此，当我吃一块巧克力时，我的大脑会立即适应这种愉悦刺激的存在，<strong>将我的平衡倾斜到与疼痛等量相反的一边</strong>。这就是后遗症或衰退，或者在我的情况下，想要第二块巧克力的那一刻。现在，如果我<strong>等待足够长的时间</strong>，这种感觉就会消失，体内平衡也会恢复。</p>
<p><strong>当快乐迅速变成痛苦或不适时</strong></p>
<p>当这种快乐&#x2F;痛苦的平衡在快乐的体验之后倾斜到痛苦的一边时，痛苦是作为许多不同的事物被主观体验的。其中之一是一种不舒服、不安、易怒、不快乐的主观感觉，以及想要重新创造快乐的感觉。但在很多方面，这也是渴望的含义：想要得到快乐，再次，全神贯注于消除我们在事后感受到的痛苦体验。我也会说，这是非常自反的。我甚至没有意识到这种后果或衰落。这可能很微妙，但我只是有点想再吃一块巧克力。</p>
</blockquote>
<p>突然想到了所谓的“男人事后一根烟”，sex行为使得多巴胺水平快速升高，而在疯狂的愉悦过后，快感消退，大脑为了恢复稳态，让“跷跷板”倾向于痛苦一侧。反映在主观感受上可能就是一种落寞和空虚吧。我想还有很多其他例子，最“臭名昭著”的莫过于短视频和电子游戏了。女朋友和我说，在刷很长一段时间的B站后（根本停不下来），会觉得精神很疲惫，然后负罪感很强，一开始刚刷的时候停不下来的兴奋不见了，反而是一种轻抑郁的状态。</p>
<p>我想这对于每一个现代人来说都是一个严肃的问题。有趣的是，我发现现代的很多生理学研究成果证明了很多古代先贤的哲学思想的正确性。比如说佛教的，有什么“俗世间的享乐都是镜中花水中月”，古希腊的斯多葛主义学派：快乐和痛苦都不会长久，安宁（平静）才是我们追求的首要目标，犬儒学派：限制你的生活条件，减少享乐，反而可以带来由衷的快乐。诸如此类。</p>
<p>有关这一方面的更多知识，可以看 <strong>《Dopamine Nation》</strong>这本书，也有关于这本书的访谈视频，可以在网上搜搜看。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>行为建议</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>王家卫《手》</title>
    <url>/2023/02/24/%E7%8E%8B%E5%AE%B6%E5%8D%AB%E3%80%8A%E6%89%8B%E3%80%8B/</url>
    <content><![CDATA[<p>大半生的痴恋起源于第一次被她手。</p>
<p>第一次总是难以忘怀。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>转载：IntelliJ调试协程</title>
    <url>/2023/02/08/%E8%BD%AC%E8%BD%BD%EF%BC%9AIntelliJ%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Debug-coroutines-using-IntelliJ-IDEA-–-tutorial"><a href="#Debug-coroutines-using-IntelliJ-IDEA-–-tutorial" class="headerlink" title="Debug coroutines using IntelliJ IDEA – tutorial"></a>Debug coroutines using IntelliJ IDEA – tutorial</h1><p>Last modified: 07 February 2023</p>
<p>This tutorial demonstrates how to create Kotlin coroutines and debug them using IntelliJ IDEA.</p>
<p>The tutorial assumes you have prior knowledge of the <a href="https://kotlinlang.org/docs/coroutines-guide.html">coroutines</a> concept.</p>
<h2 id="Create-coroutines"><a href="#Create-coroutines" class="headerlink" title="Create coroutines"></a>Create coroutines</h2><ol>
<li><p>Open a Kotlin project in IntelliJ IDEA. If you don’t have a project, <a href="https://kotlinlang.org/docs/jvm-get-started.html#create-a-project">create one</a>.</p>
</li>
<li><p>To use the <code>kotlinx.coroutines</code> library in a Gradle project, add the following dependency to <code>build.gradle(.kts)</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>For other build systems, see instructions in the <a href="https://github.com/Kotlin/kotlinx.coroutines#using-in-your-projects"><code>kotlinx.coroutines</code> README</a>.</p>
<blockquote>
<p>我的Coroutine版本是最新，但是Kotlin版本不是最新，而是1.6.24，结果调试器有问题，我更改到1.8.10最新版就可以了。</p>
</blockquote>
</li>
<li><p>Open the <code>Main.kt</code> file in <code>src/main/kotlin</code>.</p>
<p>The <code>src</code> directory contains Kotlin source files and resources. The <code>Main.kt</code> file contains sample code that will print <code>Hello World!</code>.</p>
</li>
<li><p>Change code in the <code>main()</code> function:</p>
<ul>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html"><code>runBlocking()</code></a> block to wrap a coroutine.</li>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html"><code>async()</code></a> function to create coroutines that compute deferred values <code>a</code> and <code>b</code>.</li>
<li>Use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html"><code>await()</code></a> function to await the computation result.</li>
<li>Use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/println.html"><code>println()</code></a> function to print computing status and the result of multiplication to the output.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> a = async &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m computing part of the answer&quot;</span>)</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> b = async &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m computing another part of the answer&quot;</span>)</span><br><span class="line">        <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;The answer is <span class="subst">$&#123;a.await() * b.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>Build the code by clicking <strong>Build Project</strong>.</p>
<p><img src="https://kotlinlang.org/docs/images/flow-build-project.png" alt="Build an application"></p>
</li>
</ol>
<h2 id="Debug-coroutines"><a href="#Debug-coroutines" class="headerlink" title="Debug coroutines"></a>Debug coroutines</h2><ol>
<li><p>Set breakpoints at the lines with the <code>println()</code> function call:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-breakpoint.png" alt="Build a console application"></p>
</li>
<li><p>Run the code in debug mode by clicking <strong>Debug</strong> next to the run configuration at the top of the screen.</p>
<p><img src="https://kotlinlang.org/docs/images/flow-debug-project.png" alt="Build a console application"></p>
<p>The <strong>Debug</strong> tool window appears:</p>
<ul>
<li>The <strong>Frames</strong> tab contains the call stack.</li>
<li>The <strong>Variables</strong> tab contains variables in the current context.</li>
<li>The <strong>Coroutines</strong> tab contains information on running or suspended coroutines. It shows that there are three coroutines. The first one has the <strong>RUNNING</strong> status, and the other two have the <strong>CREATED</strong> status.</li>
</ul>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-1.png" alt="Debug the coroutine"></p>
</li>
<li><p>Resume the debugger session by clicking <strong>Resume Program</strong> in the <strong>Debug</strong> tool window:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-2.png" alt="Debug the coroutine"></p>
<p>Now the <strong>Coroutines</strong> tab shows the following:</p>
<ul>
<li>The first coroutine has the <strong>SUSPENDED</strong> status – it is waiting for the values so it can multiply them.</li>
<li>The second coroutine is calculating the <code>a</code> value – it has the <strong>RUNNING</strong> status.</li>
<li>The third coroutine has the <strong>CREATED</strong> status and isn’t calculating the value of <code>b</code>.</li>
</ul>
</li>
<li><p>Resume the debugger session by clicking <strong>Resume Program</strong> in the <strong>Debug</strong> tool window:</p>
<p><img src="https://kotlinlang.org/docs/images/coroutine-debug-3.png" alt="Build a console application"></p>
<p>Now the <strong>Coroutines</strong> tab shows the following:</p>
<ul>
<li>The first coroutine has the <strong>SUSPENDED</strong> status – it is waiting for the values so it can multiply them.</li>
<li>The second coroutine has computed its value and disappeared.</li>
<li>The third coroutine is calculating the value of <code>b</code> – it has the <strong>RUNNING</strong> status.</li>
</ul>
</li>
</ol>
<p>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</p>
]]></content>
      <categories>
        <category>Kotlin</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>远离使杀戮更容易</title>
    <url>/2023/02/10/%E8%BF%9C%E7%A6%BB%E4%BD%BF%E6%9D%80%E6%88%AE%E6%9B%B4%E5%AE%B9%E6%98%93/</url>
    <content><![CDATA[<p>原文</p>
<hr>
<p>在弗兰克·赫伯特（Frank Herbert）的经典科幻小说《沙丘》中，主人公必须压制他当下的动物本能，以此来证明自己是人类。他的手被放在一个邪恶的装置——一个会产生剧痛的黑盒子里。如果他把手从盒子里抽出来，负责看守的老妇人就会用毒针刺穿他的脖子，他就会死。她告诉他：“你听说过动物为了逃离陷阱而咬断自己一条腿的事吗？那是动物的把戏。如果是一个人，他会一直待在陷阱里，忍受痛苦，假装死亡，这样他才有可能杀死捕猎者，并消除对他的同类的威胁。”</p>
<p>有些人天生比其他人更善于抑制情绪。事实上，这是与生俱来的，部分原因是他们的多巴胺受体的数量和性质异于常人。多巴胺受体是大脑中的分子，它们在多巴胺释放时会做出响应。遗传特征不同，多巴胺受体的情况也会有所差异。研究人员测量了不同人大脑中多巴胺受体的密度（受体的数量，以及它们之间距离的远近），并将其与这些人的“情绪分离”测量结果进行了比较。<br>情绪分离测试测量了一个人避免分享个人信息、避免与他人交往的倾向等特征。科学家们发现受体密度和与他人接触的倾向有直接关系，高密度的多巴胺受体与高水平的情绪分离有关。在另一项研究中，情绪分离得分最高的人将自己描述为“在人际关系中冷漠、社交冷淡、有报复心”。相比之下，情绪分离度最低的人则将自己描述为“过于热情、易被人利用”。</p>
<p>大多数人的情绪分离程度介于最高和最低之间。我们既不冷漠也不会热情过度，我们的反应取决于具体情况。如果我们与周围的人在近体空间接触——靠得很近，直接接触，专注于此刻——当下分子回路会被激活，我们性格中温暖、热情的一面就会显现出来。而如果我们在远体空间跟人打交道——保持距离，抽象思考，专注于未来——我们性格中理性、克制的部分就更容易被看到。这两种不同的思维方式可以用“电车问题”来说明：</p>
<p>一列失控的火车沿着铁轨疾驰而下，驶向5名工人。如果什么都不做，他们都会死。然而，把一个旁观者推向铁轨是有可能阻止火车的前进的。这个人的死会使火车减速，足以拯救5个工人的生命。你会把这个人推向铁轨吗？</p>
<p>在这种情景下，大多数人都不会将这个旁观者推向轨道——他们无法亲手杀死一个人，即使是为了拯救5个人的生命。当下神经递质负责产生对他人的同理心，在大多数人身上，它都会压倒多巴胺精于盘算的理性。在这种情况下，当下的反应是如此强烈，因为旁观者离得太近，就在<strong>近体空间</strong>。要杀死他，我们必须用手接触他。除了最冷漠的人，其他人都做不到。</p>
<p>但是，既然<strong>当下分子最强大的影响是在近体空间</strong>（我们五官所感知的当下世界），如果我们一步一步地后退，逐步减少当下分子对我们决策的影响，会发生什么？当我们离开当下分子的近体空间进入<strong>多巴胺能的远体空间</strong>时，我们用一条生命换5条生命的意愿是否会增加？</p>
<p>让我们先从消除身体接触的当下感觉开始。想象一下，你站在一段距离之外看着事态发展。有一个开关，拉动它，就可以将列车从有5个人的轨道转移到只有一个人的轨道；而如果什么都不做，那5个人就会死。你会拉动开关吗？</p>
<p>下面进一步把自己拉远。想象一下，你坐在距离遥远的另一座城市的办公桌旁。电话铃响了，一个语无伦次的铁路工人描述了这个情况。你在办公桌前就可以控制火车的行进路线。你可以按下一个开关，让火车转向只有一个人在上面的轨道，或者什么也不做，让火车撞向5个人。你会按下开关吗？</p>
<p>最后，我们考虑最抽象的情况：抛弃所有的当下分子，让大脑完全为多巴胺掌控。假设你是一名运输系统工程师，正在设计铁路轨道的安全特性。你在铁轨旁安装了摄像头，能够准确提供实时的信息。你需要写一个控制开关的计算机程序，该程序将使用摄像机拍下的信息来选择让火车通过哪个轨道。你会将这个软件设定为为了救5个人而杀死一个人吗？</p>
<p>以上几种场景各异，但结果是一样的：牺牲一条生命换取5条生命，或者牺牲5条生命挽救一个人。很少有人会愿意牺牲一个无辜的人，把他推向死亡。然而，如果是写一个管理轨道开关的软件来使生命损失最小化，就很少有人会犹豫了。这就好像有两个不同的人在评估情况：一个人的头脑是理性的，只根据理性来做决定；另一个人富有同情心，不管大局如何，都不愿杀人。一个人试图通过拯救最多的人来控制局势，另一个则不会。我们会选择哪个结果，在一定程度上取决于多巴胺回路中的活动。</p>
<hr>
<p>在了解到大脑对判断为属于 <strong>近体空间</strong> 的事件和属于 <strong>远体空间</strong> 的事件会产生截然不同的情绪和处理方法（理性还是非理性）之后，我联想到许久以前看过的一本有关藏传佛教的书。</p>
<p>书中简述了一种 “放下” 的状态，一种不执著于当下，不困于痛苦，也不困于兴奋的一种超脱的状态，要达到这种状态，首先要放下对“我”的执着，类似于无我。如果一个人有焦虑，抑郁等情绪，这种状态应该是他所求之不得的。而实践时的方法则是：想象自己不是自己，以一个旁观者的角度来看自己的肉体，看自己遇上的事件，当自己逐渐越来越不以 <strong>遭遇者</strong> 的身份去体验不好的事情，而是以 <strong>旁观者</strong>的身份去看待事情的话——便能放下。</p>
<p>没想到原来这还有脑科学的依据，我一直以为这只是一种心理学技巧。</p>
<p>常听有人说，看科幻小说、电影等看多了，想像宇宙的宏大、人生的短暂、人类的渺小，不自觉地感到生活的不顺心似乎也没有什么值得在意，情绪变得平静。这其实也是一种从 <strong>远体空间</strong> 看事物所带来的结果吧。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>情绪控制</tag>
      </tags>
  </entry>
  <entry>
    <title>顶部凹陷Shape</title>
    <url>/2023/02/20/%E9%A1%B6%E9%83%A8%E5%87%B9%E9%99%B7Shape/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到StackOverFlow上一个提问</p>
<p><a href="https://stackoverflow.com/questions/74278453/jetpack-compose-cardview-with-arc-shape-on-border">CardView with Arc Shape on border</a></p>
<p>提问者想知道怎么做一个控件如下图：</p>
<img src="https://i.stack.imgur.com/KY9kp.png" style="zoom:50%;" />

<p>而经过我的尝试，最终做出：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/31/bfdd7f676d26179a.png"></p>
<p>顶部的按钮就不做了，没什么难度。</p>
<h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><p>直接对Surface控件进行操作，阴影和Border都可以直接设置Surface的属性来解决，而形状通过编写一个合适的Shape类传给它来设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Surface(</span><br><span class="line">       ...</span><br><span class="line">        elevation = <span class="number">5.</span>dp,</span><br><span class="line">        color = Color.White,</span><br><span class="line">        shape = GenericShape &#123; size: Size, _: LayoutDirection -&gt;</span><br><span class="line">            buildCustomPath(size, cornerRadiusPx, centerCircleRadiusPx)<span class="comment">// 重点</span></span><br><span class="line">        &#125;,</span><br><span class="line">        border = BorderStroke(<span class="number">1.</span>dp, Color.Gray.copy(alpha = <span class="number">0.6f</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// content</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点是自定义Shape，<strong>默认已经有圆形和长方形等Shape</strong>，对于其他要求需要自己自定义。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates [Outline] of this shape for the given [size].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size the size of the shape boundary.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> layoutDirection the current layout direction.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> density the current density of the screen.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> [Outline] of this shape for the given [size].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createOutline</span><span class="params">(size: <span class="type">Size</span>, layoutDirection: <span class="type">LayoutDirection</span>, density: <span class="type">Density</span>)</span></span>: Outline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以采用创建一个匿名对象的方式，当然更方便的是使用GenericShape这个Shape的子类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericShape</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder: Path.(size: Size, layoutDirection: LayoutDirection) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : Shape &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createOutline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        size: <span class="type">Size</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        layoutDirection: <span class="type">LayoutDirection</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        density: <span class="type">Density</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Outline &#123;</span><br><span class="line">        <span class="comment">// 帮助我们写好样板代码</span></span><br><span class="line">        <span class="keyword">val</span> path = Path().apply &#123;</span><br><span class="line">            builder(size, layoutDirection)</span><br><span class="line">            close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Outline.Generic(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> (other <span class="keyword">as</span>? GenericShape)?.builder == builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.hashCode()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用GenericShape来创建Shape实例我们不用自己创建Path和Outline，直接传一个对Path进行更改的函数就行（kotlin中函数也是一个对象）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">shape = GenericShape &#123; size: Size, _: LayoutDirection -&gt;</span><br><span class="line">            buildCustomPath(size, cornerRadiusPx, centerCircleRadiusPx)<span class="comment">// 对Path()对象进行具体路径操作的函数</span></span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p>我们传的这个buildCustomPath函数根据GenericShape的源码得知会被应用于修改一个Path实例，而<strong>Path其实就代表了路径</strong>，只要这个路径是闭合的，最后就可以<strong>产生”形状“</strong>。</p>
<p>这个函数如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告知GenericShape如何对Path进行操作即如何绘制路径的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Path.<span class="title">buildCustomPath</span><span class="params">(size: <span class="type">Size</span>, cornerRadius: <span class="type">Float</span>, centerCircleRadius: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> width = size.width</span><br><span class="line">    <span class="keyword">val</span> height = size.height</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶部简化计算的</span></span><br><span class="line">    <span class="keyword">val</span> topHalfMoveLength = (width - <span class="number">2</span> * cornerRadius - <span class="number">2</span> * centerCircleRadius) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单位长度</span></span><br><span class="line">    <span class="keyword">val</span> smallCubeLength = centerCircleRadius / <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两条贝塞尔曲线共六个点</span></span><br><span class="line">    <span class="keyword">val</span> firstCubicPoint1 = Offset(</span><br><span class="line">        x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + <span class="number">8</span> * smallCubeLength,</span><br><span class="line">        y = <span class="number">1</span> * smallCubeLength</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> firstCubicPoint2 = Offset(</span><br><span class="line">        x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + <span class="number">4</span> * smallCubeLength,</span><br><span class="line">        y = <span class="number">16</span> * smallCubeLength</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> firstCubicTarget = Offset(</span><br><span class="line">        x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + centerCircleRadius,</span><br><span class="line">        y = <span class="number">16</span> * smallCubeLength</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> secondCubicPoint1 = Offset(</span><br><span class="line">        x = width - firstCubicPoint2.x,</span><br><span class="line">        y = firstCubicPoint2.y</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> secondCubicPoint2 = Offset(</span><br><span class="line">        x = width - firstCubicPoint1.x,</span><br><span class="line">        y = firstCubicPoint1.y</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> secondCubicTarget = Offset(</span><br><span class="line">        x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + <span class="number">2</span> * centerCircleRadius,</span><br><span class="line">        y = <span class="number">0f</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过移动来绘制路径</span></span><br><span class="line">    moveTo(cornerRadius, <span class="number">0f</span>)</span><br><span class="line">    lineTo(cornerRadius + topHalfMoveLength, <span class="number">0f</span>)<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    cubicTo(</span><br><span class="line">        x1 = firstCubicPoint1.x,</span><br><span class="line">        y1 = firstCubicPoint1.y,</span><br><span class="line">        x2 = firstCubicPoint2.x,</span><br><span class="line">        y2 = firstCubicPoint2.y,</span><br><span class="line">        x3 = firstCubicTarget.x,</span><br><span class="line">        y3 = firstCubicTarget.y,</span><br><span class="line">    )<span class="comment">// 2</span></span><br><span class="line">    cubicTo(</span><br><span class="line">        x1 = secondCubicPoint1.x,</span><br><span class="line">        y1 = secondCubicPoint1.y,</span><br><span class="line">        x2 = secondCubicPoint2.x,</span><br><span class="line">        y2 = secondCubicPoint2.y,</span><br><span class="line">        x3 = secondCubicTarget.x,</span><br><span class="line">        y3 = secondCubicTarget.y,</span><br><span class="line">    )<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    lineTo(width - cornerRadius, <span class="number">0f</span>)<span class="comment">// 4</span></span><br><span class="line">    arcTo(</span><br><span class="line">        rect = Rect(</span><br><span class="line">            topLeft = Offset(x = width - <span class="number">2</span> * cornerRadius, y = <span class="number">0f</span>),</span><br><span class="line">            bottomRight = Offset(x = width, y = <span class="number">2</span> * cornerRadius)</span><br><span class="line">        ),</span><br><span class="line">        startAngleDegrees = -<span class="number">90f</span>,</span><br><span class="line">        sweepAngleDegrees = <span class="number">90f</span>,</span><br><span class="line">        forceMoveTo = <span class="literal">false</span></span><br><span class="line">    )<span class="comment">// 5</span></span><br><span class="line">    lineTo(width, height - cornerRadius)<span class="comment">// 6</span></span><br><span class="line">    arcTo(</span><br><span class="line">        rect = Rect(</span><br><span class="line">            topLeft = Offset(x = width - <span class="number">2</span> * cornerRadius, y = height - <span class="number">2</span> * cornerRadius),</span><br><span class="line">            bottomRight = Offset(x = width, y = height)</span><br><span class="line">        ),</span><br><span class="line">        startAngleDegrees = <span class="number">0f</span>,</span><br><span class="line">        sweepAngleDegrees = <span class="number">90f</span>,</span><br><span class="line">        forceMoveTo = <span class="literal">false</span></span><br><span class="line">    )<span class="comment">// 7</span></span><br><span class="line">    lineTo(<span class="number">0f</span> + cornerRadius, height)<span class="comment">// 8</span></span><br><span class="line">    arcTo(</span><br><span class="line">        rect = Rect(</span><br><span class="line">            topLeft = Offset(x = <span class="number">0f</span>, y = height - <span class="number">2</span> * cornerRadius),</span><br><span class="line">            bottomRight = Offset(x = <span class="number">2</span> * cornerRadius, y = height)</span><br><span class="line">        ),</span><br><span class="line">        startAngleDegrees = <span class="number">90f</span>,</span><br><span class="line">        sweepAngleDegrees = <span class="number">90f</span>,</span><br><span class="line">        forceMoveTo = <span class="literal">false</span></span><br><span class="line">    )<span class="comment">// 9</span></span><br><span class="line">    lineTo(<span class="number">0f</span>, cornerRadius)<span class="comment">// 10</span></span><br><span class="line">    arcTo(</span><br><span class="line">        rect = Rect(</span><br><span class="line">            topLeft = Offset.Zero,</span><br><span class="line">            bottomRight = Offset(x = <span class="number">2</span> * cornerRadius, y = <span class="number">2</span> * cornerRadius)</span><br><span class="line">        ),</span><br><span class="line">        startAngleDegrees = <span class="number">180f</span>,</span><br><span class="line">        sweepAngleDegrees = <span class="number">90f</span>,</span><br><span class="line">        forceMoveTo = <span class="literal">false</span></span><br><span class="line">    )<span class="comment">// 11</span></span><br><span class="line">    close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我建议复制到你的Android Studio中然后对照着看下面的讲解。</p>
<p>先来讲主体思路，再进行详细拆解。</p>
<img src="https://s3.bmp.ovh/imgs/2023/01/31/c3d0bb437ccb4665.png" style="zoom:33%;" />

<p>首先四个角是一个圆弧，走圆弧路径的话用arcTo，怎么用后面会讲。然后中间的凹陷可以用贝塞尔曲线。贝塞尔曲线由一个起点和一个终点和两个控制点组成，由于<strong>起点已经默认是当前Path行走到的地方</strong>，所以绘制贝塞尔曲线就只剩下三个点。通过这四个点可以让曲线产生千变万化的形状，<a href="https://www.desmos.com/calculator/ebdtbxgbq0?lang=zh-CN">可以通过这个网站来看一下</a>。</p>
<blockquote>
<p>为什么中间链接的地方不用圆弧？一开始尝试过用圆弧，但是图片上是先有点向右上角凹陷再向左下角凹陷，用圆弧效果很差。</p>
</blockquote>
<p>所以就通过画直线，画圆弧，画贝塞尔曲线来构建这个形状就可以了。</p>
<p>下面进行详细拆解。</p>
<p>在画第一条直线时，先调用了这行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">moveTo(cornerRadius, <span class="number">0f</span>)</span><br></pre></td></tr></table></figure>

<p>这是因为起点一开始是在（0，0）处，如果不了解Android坐标系规则先去了解。所以为了画第一条直线，如上图，先把起点移出来。然后在注释1处画一条直线。</p>
<p>那么轮到画贝塞尔曲线了，这个时候要注意，因为画了线，所以现在起点在1处末尾。</p>
<p>这个时候，可以使用上面那个网站，先根据大概的样式控制四个点得到曲线，然后在把控制点1、控制点2、终点 <strong>转换到Android坐标系上</strong>，</p>
<img src="https://s3.bmp.ovh/imgs/2023/01/31/17f71c35c8239ea6.png" style="zoom:33%;" />

<p>在上面的坐标系上，终点至起点相距 20个小格子，在代码上相当于centerCircleRadius的长度，所以一个小格子就是centerCircleRadius &#x2F; 20.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单位长度</span></span><br><span class="line">    <span class="keyword">val</span> smallCubeLength = centerCircleRadius / <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>这个时候得到点在Android坐标系上的坐标就容易了。举控制点1为例子。</p>
<p>控制点1的x坐标比起点多 8个小格子长度，所以</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + <span class="number">8</span> * smallCubeLength,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为此时起点的坐标已为 1 * cornerRadius + topHalfMoveLength</p>
</blockquote>
<p>y坐标刚好为1个小格子长度，所以</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">y = <span class="number">1</span> * smallCubeLength</span><br></pre></td></tr></table></figure>

<p>所以控制点1的坐标为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> firstCubicPoint1 = Offset(</span><br><span class="line">        x = <span class="number">1</span> * cornerRadius + topHalfMoveLength + <span class="number">8</span> * smallCubeLength,</span><br><span class="line">        y = <span class="number">1</span> * smallCubeLength</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:exclamation:注意，这些坐标都是相对整个坐标系的，不是相对起点:exclamation:</p>
</blockquote>
<p>其他点类推。</p>
<p>下面说画圆弧的方法。</p>
<p>如上上图，<strong>圆弧其实是一个长方形的内切椭圆的任意一个点到另外一个点的线段</strong>，确定了长方形，起始角度，滑动距离，就可以唯一确定一条圆弧。</p>
<p>需要注意的是 forceMoveTo这个参数，<strong>当圆弧的起点和当前起点不一样才有意义，不然是true是false无所谓</strong>。区别是</p>
<table>
<thead>
<tr>
<th>true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>在当前起点和圆弧起点没有直线连接</td>
<td>在当前起点和圆弧起点有一条直线连接</td>
</tr>
</tbody></table>
<p>所以我才说当圆弧的起点和当前起点不一样才有意义。建议设置为false，如果圆弧的起点和当前起点不一样，也可以<strong>闭合路径</strong>。</p>
<p>最后调不调用close()来闭合都无所谓，因为GenericShape源码中有调用。当然还是显式调用一下好。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://gist.github.com/JeckOnly/54936415d1670103a4d400f66c8b31a1">GitHub</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
        <category>Compose</category>
        <category>自定义组件</category>
      </categories>
  </entry>
</search>
